{"errors":[],"warnings":[],"version":"1.12.6","hash":"10c63572137300d4804c","time":4749,"publicPath":"","assetsByChunkName":{"main":["auru.js","auru.js.map"]},"assets":[{"name":"auru.js","size":96592,"chunks":[0],"chunkNames":["main"],"emitted":true},{"name":"auru.js.map","size":101800,"chunks":[0],"chunkNames":["main"],"emitted":true}],"chunks":[{"id":0,"rendered":true,"initial":true,"entry":true,"extraAsync":false,"size":91724,"names":["main"],"files":["auru.js","auru.js.map"],"hash":"d323ee92a4d1797ad0d3","parents":[],"origins":[{"moduleId":0,"module":"/home/paul/auru/node_modules/babel-loader/index.js!/home/paul/auru/auru.js","moduleIdentifier":"/home/paul/auru/node_modules/babel-loader/index.js!/home/paul/auru/auru.js","moduleName":"./auru.js","loc":"","name":"main","reasons":[]}]}],"modules":[{"id":0,"identifier":"/home/paul/auru/node_modules/babel-loader/index.js!/home/paul/auru/auru.js","name":"./auru.js","index":0,"index2":4,"size":7322,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":null,"failed":false,"errors":0,"warnings":0,"reasons":[],"source":"'use strict';\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar EventEmitter = require('eventemitter3');\nvar Hammer;\nif (process.env.hammer) {\n\tHammer = require('hammerjs');\n}\n\nvar defaultOptions = {\n\tslideDuration: 5, // how many seconds to show each slide, false to not play automatically\n\tclassPrefix: 'auru-',\n\tcontinuousLoop: true,\n\ttouch: true\n};\n\nfunction dumbMerge(first, second) {\n\tvar copy = {};\n\tfor (var key in first) {\n\t\tcopy[key] = first[key];\n\t}\n\tfor (var key in second) {\n\t\tcopy[key] = second[key];\n\t}\n\treturn copy;\n}\n\nvar Auru = (function (_EventEmitter) {\n\t_inherits(Auru, _EventEmitter);\n\n\tfunction Auru(element, options) {\n\t\t_classCallCheck(this, Auru);\n\n\t\tvar _this2 = _possibleConstructorReturn(this, Object.getPrototypeOf(Auru).call(this));\n\n\t\t_this2.element = element;\n\t\t_this2.options = dumbMerge(defaultOptions, options || {});\n\n\t\t_this2.playing = false;\n\t\t_this2.currentIndex = 0;\n\t\t_this2.maxIndex = _this2.element.children.length - 1;\n\t\t_this2.previousSlide = _this2.element.children[_this2.maxIndex];\n\t\t_this2.currentSlide = _this2.element.children[_this2.currentIndex];\n\n\t\t_this2._initializeClasses();\n\n\t\tif (process.env.hammer && _this2.options.touch) {\n\t\t\t_this2._initializeTouchEvents();\n\t\t}\n\n\t\tif (_this2.options.slideDuration) {\n\t\t\t_this2.play();\n\t\t}\n\t\treturn _this2;\n\t}\n\n\t_createClass(Auru, [{\n\t\tkey: '_initializeClasses',\n\t\tvalue: function _initializeClasses() {\n\t\t\tvar prefix = this.options.classPrefix,\n\t\t\t    i = 0;\n\t\t\tthis.element.classList.add(prefix + 'slideshow');\n\t\t\tArray.prototype.forEach.call(this.element.children, function (childNode) {\n\t\t\t\tchildNode.classList.add(prefix + 'slide');\n\t\t\t\tif (i === 0) {\n\t\t\t\t\tchildNode.classList.add(prefix + 'current');\n\t\t\t\t} else {\n\t\t\t\t\tchildNode.classList.add(prefix + 'hidden');\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t});\n\t\t}\n\t}, {\n\t\tkey: '_removeClasses',\n\t\tvalue: function _removeClasses() {\n\t\t\tvar prefix = this.options.classPrefix,\n\t\t\t    i = 0;\n\t\t\tthis.element.classList.remove(prefix + 'slideshow');\n\t\t\tArray.prototype.forEach.call(this.element.children, function (childNode) {\n\t\t\t\tchildNode.classList.remove(prefix + 'slide', prefix + 'current', prefix + 'previous', prefix + 'to-right', prefix + 'to-left', prefix + 'from-right', prefix + 'from-left');\n\t\t\t\ti++;\n\t\t\t});\n\t\t}\n\t}, {\n\t\tkey: '_initializeTouchEvents',\n\t\tvalue: function _initializeTouchEvents() {\n\t\t\tvar _this = this;\n\n\t\t\tthis.hammer = new Hammer(this.element);\n\t\t\tthis.hammer.on('swipeleft', this.next.bind(this));\n\t\t\tthis.hammer.on('swiperight', this.previous.bind(this));\n\t\t\tthis.hammer.on('tap', function () {\n\t\t\t\t_this.emit('tap');\n\t\t\t});\n\t\t}\n\t}, {\n\t\tkey: '_removeAnimationClasses',\n\t\tvalue: function _removeAnimationClasses(elem) {\n\t\t\tvar prefix = this.options.classPrefix;\n\t\t\telem.classList.remove(prefix + 'to-right', prefix + 'to-left', prefix + 'from-right', prefix + 'from-left');\n\t\t}\n\t}, {\n\t\tkey: 'play',\n\t\tvalue: function play() {\n\t\t\tif (this.playing) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.playing = true;\n\t\t\tthis.timer = setInterval(this.next.bind(this), this.options.slideDuration * 1000);\n\t\t}\n\t}, {\n\t\tkey: 'stop',\n\t\tvalue: function stop() {\n\t\t\tthis.playing = false;\n\t\t\tclearInterval(this.timer);\n\t\t}\n\t}, {\n\t\tkey: 'next',\n\t\tvalue: function next() {\n\t\t\tvar nextIndex = this.currentIndex + 1;\n\t\t\tif (nextIndex > this.maxIndex) {\n\t\t\t\tnextIndex = 0;\n\t\t\t}\n\t\t\treturn this.goToSlide(nextIndex);\n\t\t}\n\t}, {\n\t\tkey: 'previous',\n\t\tvalue: function previous() {\n\t\t\tvar nextIndex = this.currentIndex - 1;\n\t\t\tif (nextIndex < 0) {\n\t\t\t\tnextIndex = this.maxIndex;\n\t\t\t}\n\t\t\treturn this.goToSlide(nextIndex);\n\t\t}\n\t}, {\n\t\tkey: 'goToSlide',\n\t\tvalue: function goToSlide(index) {\n\t\t\tvar prefix, children, oldPrevious, previous, current, oldIndex;\n\n\t\t\tif (index < 0 || index > this.maxIndex) {\n\t\t\t\tthrow new TypeError('Slide index out of bounds');\n\t\t\t}\n\n\t\t\tif (index === this.currentIndex) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tprefix = this.options.classPrefix;\n\t\t\tchildren = this.element.children;\n\n\t\t\toldPrevious = this.previousSlide;\n\t\t\tprevious = this.currentSlide;\n\n\t\t\toldIndex = this.currentIndex;\n\t\t\tthis.currentIndex = index;\n\t\t\tcurrent = children[index];\n\n\t\t\tthis._removeAnimationClasses(oldPrevious);\n\t\t\toldPrevious.classList.remove(prefix + 'previous');\n\t\t\toldPrevious.classList.add(prefix + 'hidden');\n\n\t\t\tthis._removeAnimationClasses(previous);\n\t\t\tprevious.classList.remove(prefix + 'current');\n\t\t\tprevious.classList.add(prefix + 'previous');\n\t\t\tif (this.options.continuousLoop && this.currentIndex === 0 && oldIndex === this.maxIndex) {\n\t\t\t\tprevious.classList.add(prefix + 'to-left');\n\t\t\t} else if (this.options.continuousLoop && this.currentIndex === this.maxIndex && oldIndex === 0) {\n\t\t\t\tprevious.classList.add(prefix + 'to-right');\n\t\t\t} else if (this.currentIndex > oldIndex) {\n\t\t\t\tprevious.classList.add(prefix + 'to-left');\n\t\t\t} else {\n\t\t\t\tprevious.classList.add(prefix + 'to-right');\n\t\t\t}\n\n\t\t\tcurrent.classList.remove(prefix + 'hidden');\n\t\t\tcurrent.classList.add(prefix + 'current');\n\t\t\tif (this.options.continuousLoop && this.currentIndex === 0 && oldIndex === this.maxIndex) {\n\t\t\t\tcurrent.classList.add(prefix + 'from-right');\n\t\t\t} else if (this.options.continuousLoop && this.currentIndex === this.maxIndex && oldIndex === 0) {\n\t\t\t\tcurrent.classList.add(prefix + 'from-left');\n\t\t\t} else if (this.currentIndex > oldIndex) {\n\t\t\t\tcurrent.classList.add(prefix + 'from-right');\n\t\t\t} else {\n\t\t\t\tcurrent.classList.add(prefix + 'from-left');\n\t\t\t}\n\n\t\t\tthis.previousSlide = previous;\n\t\t\tthis.currentSlide = current;\n\n\t\t\t//this.options.onChange();\n\t\t\tthis.emit('change');\n\t\t}\n\t}, {\n\t\tkey: 'destroy',\n\t\tvalue: function destroy(removeClasses) {\n\t\t\tvar prefix;\n\t\t\tif (process.env.hammer && this.options.touch) {\n\t\t\t\tthis.hammer.destroy();\n\t\t\t}\n\t\t\tif (removeClasses) {\n\t\t\t\tthis._removeClasses();\n\t\t\t}\n\t\t\tthis.removeAllListeners();\n\t\t}\n\t}]);\n\n\treturn Auru;\n})(EventEmitter);\n\nexports.default = Auru;\nmodule.exports = exports['default'];"},{"id":1,"identifier":"/home/paul/auru/node_modules/babel-loader/index.js!/home/paul/auru/node_modules/eventemitter3/index.js","name":"./~/eventemitter3/index.js","index":1,"index2":0,"size":7125,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/home/paul/auru/node_modules/babel-loader/index.js!/home/paul/auru/auru.js","failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":0,"moduleIdentifier":"/home/paul/auru/node_modules/babel-loader/index.js!/home/paul/auru/auru.js","module":"./auru.js","moduleName":"./auru.js","type":"cjs require","userRequest":"eventemitter3","loc":"15:19-43"}],"source":"'use strict'\n\n//\n// We store our EE objects in a plain object whose properties are event names.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// `~` to make sure that the built-in object properties are not overridden or\n// used as an attack vector.\n// We also assume that `Object.create(null)` is available when the event name\n// is an ES6 Symbol.\n//\n;\nvar prefix = typeof Object.create !== 'function' ? '~' : false;\n\n/**\n * Representation of a single EventEmitter function.\n *\n * @param {Function} fn Event handler to be called.\n * @param {Mixed} context Context for function execution.\n * @param {Boolean} once Only emit once\n * @api private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Minimal EventEmitter interface that is molded against the Node.js\n * EventEmitter interface.\n *\n * @constructor\n * @api public\n */\nfunction EventEmitter() {} /* Nothing to set */\n\n/**\n * Holds the assigned EventEmitters by name.\n *\n * @type {Object}\n * @private\n */\nEventEmitter.prototype._events = undefined;\n\n/**\n * Return a list of assigned event listeners.\n *\n * @param {String} event The events that should be listed.\n * @param {Boolean} exists We only need to know if there are listeners.\n * @returns {Array|Boolean}\n * @api public\n */\nEventEmitter.prototype.listeners = function listeners(event, exists) {\n  var evt = prefix ? prefix + event : event,\n      available = this._events && this._events[evt];\n\n  if (exists) return !!available;\n  if (!available) return [];\n  if (available.fn) return [available.fn];\n\n  for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {\n    ee[i] = available[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Emit an event to all registered event listeners.\n *\n * @param {String} event The name of the event.\n * @returns {Boolean} Indication if we've emitted an event.\n * @api public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events || !this._events[evt]) return false;\n\n  var listeners = this._events[evt],\n      len = arguments.length,\n      args,\n      i;\n\n  if ('function' === typeof listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1:\n        return listeners.fn.call(listeners.context), true;\n      case 2:\n        return listeners.fn.call(listeners.context, a1), true;\n      case 3:\n        return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4:\n        return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5:\n        return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6:\n        return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len - 1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length,\n        j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1:\n          listeners[i].fn.call(listeners[i].context);break;\n        case 2:\n          listeners[i].fn.call(listeners[i].context, a1);break;\n        case 3:\n          listeners[i].fn.call(listeners[i].context, a1, a2);break;\n        default:\n          if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Register a new EventListener for the given event.\n *\n * @param {String} event Name of the event.\n * @param {Functon} fn Callback function.\n * @param {Mixed} context The context of the function.\n * @api public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  var listener = new EE(fn, context || this),\n      evt = prefix ? prefix + event : event;\n\n  if (!this._events) this._events = prefix ? {} : Object.create(null);\n  if (!this._events[evt]) this._events[evt] = listener;else {\n    if (!this._events[evt].fn) this._events[evt].push(listener);else this._events[evt] = [this._events[evt], listener];\n  }\n\n  return this;\n};\n\n/**\n * Add an EventListener that's only called once.\n *\n * @param {String} event Name of the event.\n * @param {Function} fn Callback function.\n * @param {Mixed} context The context of the function.\n * @api public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  var listener = new EE(fn, context || this, true),\n      evt = prefix ? prefix + event : event;\n\n  if (!this._events) this._events = prefix ? {} : Object.create(null);\n  if (!this._events[evt]) this._events[evt] = listener;else {\n    if (!this._events[evt].fn) this._events[evt].push(listener);else this._events[evt] = [this._events[evt], listener];\n  }\n\n  return this;\n};\n\n/**\n * Remove event listeners.\n *\n * @param {String} event The event we want to remove.\n * @param {Function} fn The listener that we need to find.\n * @param {Mixed} context Only remove listeners matching this context.\n * @param {Boolean} once Only remove once listeners.\n * @api public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events || !this._events[evt]) return this;\n\n  var listeners = this._events[evt],\n      events = [];\n\n  if (fn) {\n    if (listeners.fn) {\n      if (listeners.fn !== fn || once && !listeners.once || context && listeners.context !== context) {\n        events.push(listeners);\n      }\n    } else {\n      for (var i = 0, length = listeners.length; i < length; i++) {\n        if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {\n          events.push(listeners[i]);\n        }\n      }\n    }\n  }\n\n  //\n  // Reset the array, or remove it completely if we have no more listeners.\n  //\n  if (events.length) {\n    this._events[evt] = events.length === 1 ? events[0] : events;\n  } else {\n    delete this._events[evt];\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners or only the listeners for the specified event.\n *\n * @param {String} event The event want to remove all listeners for.\n * @api public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  if (!this._events) return this;\n\n  if (event) delete this._events[prefix ? prefix + event : event];else this._events = prefix ? {} : Object.create(null);\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// This function doesn't apply anymore.\n//\nEventEmitter.prototype.setMaxListeners = function setMaxListeners() {\n  return this;\n};\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}"},{"id":2,"identifier":"/home/paul/auru/node_modules/babel-loader/index.js!/home/paul/auru/node_modules/hammerjs/hammer.js","name":"./~/hammerjs/hammer.js","index":2,"index2":3,"size":77149,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/home/paul/auru/node_modules/babel-loader/index.js!/home/paul/auru/auru.js","failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":0,"moduleIdentifier":"/home/paul/auru/node_modules/babel-loader/index.js!/home/paul/auru/auru.js","module":"./auru.js","moduleName":"./auru.js","type":"cjs require","userRequest":"hammerjs","loc":"18:10-29"}],"source":"'use strict';\n\nfunction _typeof(obj) { return obj && typeof Symbol !== \"undefined\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; }\n\n/*! Hammer.JS - v2.0.4 - 2014-09-28\r\n * http://hammerjs.github.io/\r\n *\r\n * Copyright (c) 2014 Jorik Tangelder;\r\n * Licensed under the MIT license */\n(function (window, document, exportName, undefined) {\n    'use strict';\n\n    var VENDOR_PREFIXES = ['', 'webkit', 'moz', 'MS', 'ms', 'o'];\n    var TEST_ELEMENT = document.createElement('div');\n\n    var TYPE_FUNCTION = 'function';\n\n    var round = Math.round;\n    var abs = Math.abs;\n    var now = Date.now;\n\n    /**\r\n     * set a timeout with a given scope\r\n     * @param {Function} fn\r\n     * @param {Number} timeout\r\n     * @param {Object} context\r\n     * @returns {number}\r\n     */\n    function setTimeoutContext(fn, timeout, context) {\n        return setTimeout(bindFn(fn, context), timeout);\n    }\n\n    /**\r\n     * if the argument is an array, we want to execute the fn on each entry\r\n     * if it aint an array we don't want to do a thing.\r\n     * this is used by all the methods that accept a single and array argument.\r\n     * @param {*|Array} arg\r\n     * @param {String} fn\r\n     * @param {Object} [context]\r\n     * @returns {Boolean}\r\n     */\n    function invokeArrayArg(arg, fn, context) {\n        if (Array.isArray(arg)) {\n            each(arg, context[fn], context);\n            return true;\n        }\n        return false;\n    }\n\n    /**\r\n     * walk objects and arrays\r\n     * @param {Object} obj\r\n     * @param {Function} iterator\r\n     * @param {Object} context\r\n     */\n    function each(obj, iterator, context) {\n        var i;\n\n        if (!obj) {\n            return;\n        }\n\n        if (obj.forEach) {\n            obj.forEach(iterator, context);\n        } else if (obj.length !== undefined) {\n            i = 0;\n            while (i < obj.length) {\n                iterator.call(context, obj[i], i, obj);\n                i++;\n            }\n        } else {\n            for (i in obj) {\n                obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n            }\n        }\n    }\n\n    /**\r\n     * extend object.\r\n     * means that properties in dest will be overwritten by the ones in src.\r\n     * @param {Object} dest\r\n     * @param {Object} src\r\n     * @param {Boolean} [merge]\r\n     * @returns {Object} dest\r\n     */\n    function extend(dest, src, merge) {\n        var keys = Object.keys(src);\n        var i = 0;\n        while (i < keys.length) {\n            if (!merge || merge && dest[keys[i]] === undefined) {\n                dest[keys[i]] = src[keys[i]];\n            }\n            i++;\n        }\n        return dest;\n    }\n\n    /**\r\n     * merge the values from src in the dest.\r\n     * means that properties that exist in dest will not be overwritten by src\r\n     * @param {Object} dest\r\n     * @param {Object} src\r\n     * @returns {Object} dest\r\n     */\n    function merge(dest, src) {\n        return extend(dest, src, true);\n    }\n\n    /**\r\n     * simple class inheritance\r\n     * @param {Function} child\r\n     * @param {Function} base\r\n     * @param {Object} [properties]\r\n     */\n    function inherit(child, base, properties) {\n        var baseP = base.prototype,\n            childP;\n\n        childP = child.prototype = Object.create(baseP);\n        childP.constructor = child;\n        childP._super = baseP;\n\n        if (properties) {\n            extend(childP, properties);\n        }\n    }\n\n    /**\r\n     * simple function bind\r\n     * @param {Function} fn\r\n     * @param {Object} context\r\n     * @returns {Function}\r\n     */\n    function bindFn(fn, context) {\n        return function boundFn() {\n            return fn.apply(context, arguments);\n        };\n    }\n\n    /**\r\n     * let a boolean value also be a function that must return a boolean\r\n     * this first item in args will be used as the context\r\n     * @param {Boolean|Function} val\r\n     * @param {Array} [args]\r\n     * @returns {Boolean}\r\n     */\n    function boolOrFn(val, args) {\n        if ((typeof val === 'undefined' ? 'undefined' : _typeof(val)) == TYPE_FUNCTION) {\n            return val.apply(args ? args[0] || undefined : undefined, args);\n        }\n        return val;\n    }\n\n    /**\r\n     * use the val2 when val1 is undefined\r\n     * @param {*} val1\r\n     * @param {*} val2\r\n     * @returns {*}\r\n     */\n    function ifUndefined(val1, val2) {\n        return val1 === undefined ? val2 : val1;\n    }\n\n    /**\r\n     * addEventListener with multiple events at once\r\n     * @param {EventTarget} target\r\n     * @param {String} types\r\n     * @param {Function} handler\r\n     */\n    function addEventListeners(target, types, handler) {\n        each(splitStr(types), function (type) {\n            target.addEventListener(type, handler, false);\n        });\n    }\n\n    /**\r\n     * removeEventListener with multiple events at once\r\n     * @param {EventTarget} target\r\n     * @param {String} types\r\n     * @param {Function} handler\r\n     */\n    function removeEventListeners(target, types, handler) {\n        each(splitStr(types), function (type) {\n            target.removeEventListener(type, handler, false);\n        });\n    }\n\n    /**\r\n     * find if a node is in the given parent\r\n     * @method hasParent\r\n     * @param {HTMLElement} node\r\n     * @param {HTMLElement} parent\r\n     * @return {Boolean} found\r\n     */\n    function hasParent(node, parent) {\n        while (node) {\n            if (node == parent) {\n                return true;\n            }\n            node = node.parentNode;\n        }\n        return false;\n    }\n\n    /**\r\n     * small indexOf wrapper\r\n     * @param {String} str\r\n     * @param {String} find\r\n     * @returns {Boolean} found\r\n     */\n    function inStr(str, find) {\n        return str.indexOf(find) > -1;\n    }\n\n    /**\r\n     * split string on whitespace\r\n     * @param {String} str\r\n     * @returns {Array} words\r\n     */\n    function splitStr(str) {\n        return str.trim().split(/\\s+/g);\n    }\n\n    /**\r\n     * find if a array contains the object using indexOf or a simple polyFill\r\n     * @param {Array} src\r\n     * @param {String} find\r\n     * @param {String} [findByKey]\r\n     * @return {Boolean|Number} false when not found, or the index\r\n     */\n    function inArray(src, find, findByKey) {\n        if (src.indexOf && !findByKey) {\n            return src.indexOf(find);\n        } else {\n            var i = 0;\n            while (i < src.length) {\n                if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {\n                    return i;\n                }\n                i++;\n            }\n            return -1;\n        }\n    }\n\n    /**\r\n     * convert array-like objects to real arrays\r\n     * @param {Object} obj\r\n     * @returns {Array}\r\n     */\n    function toArray(obj) {\n        return Array.prototype.slice.call(obj, 0);\n    }\n\n    /**\r\n     * unique array with objects based on a key (like 'id') or just by the array's value\r\n     * @param {Array} src [{id:1},{id:2},{id:1}]\r\n     * @param {String} [key]\r\n     * @param {Boolean} [sort=False]\r\n     * @returns {Array} [{id:1},{id:2}]\r\n     */\n    function uniqueArray(src, key, sort) {\n        var results = [];\n        var values = [];\n        var i = 0;\n\n        while (i < src.length) {\n            var val = key ? src[i][key] : src[i];\n            if (inArray(values, val) < 0) {\n                results.push(src[i]);\n            }\n            values[i] = val;\n            i++;\n        }\n\n        if (sort) {\n            if (!key) {\n                results = results.sort();\n            } else {\n                results = results.sort(function sortUniqueArray(a, b) {\n                    return a[key] > b[key];\n                });\n            }\n        }\n\n        return results;\n    }\n\n    /**\r\n     * get the prefixed property\r\n     * @param {Object} obj\r\n     * @param {String} property\r\n     * @returns {String|Undefined} prefixed\r\n     */\n    function prefixed(obj, property) {\n        var prefix, prop;\n        var camelProp = property[0].toUpperCase() + property.slice(1);\n\n        var i = 0;\n        while (i < VENDOR_PREFIXES.length) {\n            prefix = VENDOR_PREFIXES[i];\n            prop = prefix ? prefix + camelProp : property;\n\n            if (prop in obj) {\n                return prop;\n            }\n            i++;\n        }\n        return undefined;\n    }\n\n    /**\r\n     * get a unique id\r\n     * @returns {number} uniqueId\r\n     */\n    var _uniqueId = 1;\n    function uniqueId() {\n        return _uniqueId++;\n    }\n\n    /**\r\n     * get the window object of an element\r\n     * @param {HTMLElement} element\r\n     * @returns {DocumentView|Window}\r\n     */\n    function getWindowForElement(element) {\n        var doc = element.ownerDocument;\n        return doc.defaultView || doc.parentWindow;\n    }\n\n    var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\n\n    var SUPPORT_TOUCH = 'ontouchstart' in window;\n    var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\n    var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\n\n    var INPUT_TYPE_TOUCH = 'touch';\n    var INPUT_TYPE_PEN = 'pen';\n    var INPUT_TYPE_MOUSE = 'mouse';\n    var INPUT_TYPE_KINECT = 'kinect';\n\n    var COMPUTE_INTERVAL = 25;\n\n    var INPUT_START = 1;\n    var INPUT_MOVE = 2;\n    var INPUT_END = 4;\n    var INPUT_CANCEL = 8;\n\n    var DIRECTION_NONE = 1;\n    var DIRECTION_LEFT = 2;\n    var DIRECTION_RIGHT = 4;\n    var DIRECTION_UP = 8;\n    var DIRECTION_DOWN = 16;\n\n    var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\n    var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\n    var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\n\n    var PROPS_XY = ['x', 'y'];\n    var PROPS_CLIENT_XY = ['clientX', 'clientY'];\n\n    /**\r\n     * create new input type manager\r\n     * @param {Manager} manager\r\n     * @param {Function} callback\r\n     * @returns {Input}\r\n     * @constructor\r\n     */\n    function Input(manager, callback) {\n        var self = this;\n        this.manager = manager;\n        this.callback = callback;\n        this.element = manager.element;\n        this.target = manager.options.inputTarget;\n\n        // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n        // so when disabled the input events are completely bypassed.\n        this.domHandler = function (ev) {\n            if (boolOrFn(manager.options.enable, [manager])) {\n                self.handler(ev);\n            }\n        };\n\n        this.init();\n    }\n\n    Input.prototype = {\n        /**\r\n         * should handle the inputEvent data and trigger the callback\r\n         * @virtual\r\n         */\n        handler: function handler() {},\n\n        /**\r\n         * bind the events\r\n         */\n        init: function init() {\n            this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n            this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n            this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n        },\n\n        /**\r\n         * unbind the events\r\n         */\n        destroy: function destroy() {\n            this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n            this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n            this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n        }\n    };\n\n    /**\r\n     * create new input type manager\r\n     * called by the Manager constructor\r\n     * @param {Hammer} manager\r\n     * @returns {Input}\r\n     */\n    function createInputInstance(manager) {\n        var Type;\n        var inputClass = manager.options.inputClass;\n\n        if (inputClass) {\n            Type = inputClass;\n        } else if (SUPPORT_POINTER_EVENTS) {\n            Type = PointerEventInput;\n        } else if (SUPPORT_ONLY_TOUCH) {\n            Type = TouchInput;\n        } else if (!SUPPORT_TOUCH) {\n            Type = MouseInput;\n        } else {\n            Type = TouchMouseInput;\n        }\n        return new Type(manager, inputHandler);\n    }\n\n    /**\r\n     * handle input events\r\n     * @param {Manager} manager\r\n     * @param {String} eventType\r\n     * @param {Object} input\r\n     */\n    function inputHandler(manager, eventType, input) {\n        var pointersLen = input.pointers.length;\n        var changedPointersLen = input.changedPointers.length;\n        var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;\n        var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;\n\n        input.isFirst = !!isFirst;\n        input.isFinal = !!isFinal;\n\n        if (isFirst) {\n            manager.session = {};\n        }\n\n        // source event is the normalized value of the domEvents\n        // like 'touchstart, mouseup, pointerdown'\n        input.eventType = eventType;\n\n        // compute scale, rotation etc\n        computeInputData(manager, input);\n\n        // emit secret event\n        manager.emit('hammer.input', input);\n\n        manager.recognize(input);\n        manager.session.prevInput = input;\n    }\n\n    /**\r\n     * extend the data with some usable properties like scale, rotate, velocity etc\r\n     * @param {Object} manager\r\n     * @param {Object} input\r\n     */\n    function computeInputData(manager, input) {\n        var session = manager.session;\n        var pointers = input.pointers;\n        var pointersLength = pointers.length;\n\n        // store the first input to calculate the distance and direction\n        if (!session.firstInput) {\n            session.firstInput = simpleCloneInputData(input);\n        }\n\n        // to compute scale and rotation we need to store the multiple touches\n        if (pointersLength > 1 && !session.firstMultiple) {\n            session.firstMultiple = simpleCloneInputData(input);\n        } else if (pointersLength === 1) {\n            session.firstMultiple = false;\n        }\n\n        var firstInput = session.firstInput;\n        var firstMultiple = session.firstMultiple;\n        var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n\n        var center = input.center = getCenter(pointers);\n        input.timeStamp = now();\n        input.deltaTime = input.timeStamp - firstInput.timeStamp;\n\n        input.angle = getAngle(offsetCenter, center);\n        input.distance = getDistance(offsetCenter, center);\n\n        computeDeltaXY(session, input);\n        input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n\n        input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n        input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n\n        computeIntervalInputData(session, input);\n\n        // find the correct target\n        var target = manager.element;\n        if (hasParent(input.srcEvent.target, target)) {\n            target = input.srcEvent.target;\n        }\n        input.target = target;\n    }\n\n    function computeDeltaXY(session, input) {\n        var center = input.center;\n        var offset = session.offsetDelta || {};\n        var prevDelta = session.prevDelta || {};\n        var prevInput = session.prevInput || {};\n\n        if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n            prevDelta = session.prevDelta = {\n                x: prevInput.deltaX || 0,\n                y: prevInput.deltaY || 0\n            };\n\n            offset = session.offsetDelta = {\n                x: center.x,\n                y: center.y\n            };\n        }\n\n        input.deltaX = prevDelta.x + (center.x - offset.x);\n        input.deltaY = prevDelta.y + (center.y - offset.y);\n    }\n\n    /**\r\n     * velocity is calculated every x ms\r\n     * @param {Object} session\r\n     * @param {Object} input\r\n     */\n    function computeIntervalInputData(session, input) {\n        var last = session.lastInterval || input,\n            deltaTime = input.timeStamp - last.timeStamp,\n            velocity,\n            velocityX,\n            velocityY,\n            direction;\n\n        if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n            var deltaX = last.deltaX - input.deltaX;\n            var deltaY = last.deltaY - input.deltaY;\n\n            var v = getVelocity(deltaTime, deltaX, deltaY);\n            velocityX = v.x;\n            velocityY = v.y;\n            velocity = abs(v.x) > abs(v.y) ? v.x : v.y;\n            direction = getDirection(deltaX, deltaY);\n\n            session.lastInterval = input;\n        } else {\n            // use latest velocity info if it doesn't overtake a minimum period\n            velocity = last.velocity;\n            velocityX = last.velocityX;\n            velocityY = last.velocityY;\n            direction = last.direction;\n        }\n\n        input.velocity = velocity;\n        input.velocityX = velocityX;\n        input.velocityY = velocityY;\n        input.direction = direction;\n    }\n\n    /**\r\n     * create a simple clone from the input used for storage of firstInput and firstMultiple\r\n     * @param {Object} input\r\n     * @returns {Object} clonedInputData\r\n     */\n    function simpleCloneInputData(input) {\n        // make a simple copy of the pointers because we will get a reference if we don't\n        // we only need clientXY for the calculations\n        var pointers = [];\n        var i = 0;\n        while (i < input.pointers.length) {\n            pointers[i] = {\n                clientX: round(input.pointers[i].clientX),\n                clientY: round(input.pointers[i].clientY)\n            };\n            i++;\n        }\n\n        return {\n            timeStamp: now(),\n            pointers: pointers,\n            center: getCenter(pointers),\n            deltaX: input.deltaX,\n            deltaY: input.deltaY\n        };\n    }\n\n    /**\r\n     * get the center of all the pointers\r\n     * @param {Array} pointers\r\n     * @return {Object} center contains `x` and `y` properties\r\n     */\n    function getCenter(pointers) {\n        var pointersLength = pointers.length;\n\n        // no need to loop when only one touch\n        if (pointersLength === 1) {\n            return {\n                x: round(pointers[0].clientX),\n                y: round(pointers[0].clientY)\n            };\n        }\n\n        var x = 0,\n            y = 0,\n            i = 0;\n        while (i < pointersLength) {\n            x += pointers[i].clientX;\n            y += pointers[i].clientY;\n            i++;\n        }\n\n        return {\n            x: round(x / pointersLength),\n            y: round(y / pointersLength)\n        };\n    }\n\n    /**\r\n     * calculate the velocity between two points. unit is in px per ms.\r\n     * @param {Number} deltaTime\r\n     * @param {Number} x\r\n     * @param {Number} y\r\n     * @return {Object} velocity `x` and `y`\r\n     */\n    function getVelocity(deltaTime, x, y) {\n        return {\n            x: x / deltaTime || 0,\n            y: y / deltaTime || 0\n        };\n    }\n\n    /**\r\n     * get the direction between two points\r\n     * @param {Number} x\r\n     * @param {Number} y\r\n     * @return {Number} direction\r\n     */\n    function getDirection(x, y) {\n        if (x === y) {\n            return DIRECTION_NONE;\n        }\n\n        if (abs(x) >= abs(y)) {\n            return x > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n        }\n        return y > 0 ? DIRECTION_UP : DIRECTION_DOWN;\n    }\n\n    /**\r\n     * calculate the absolute distance between two points\r\n     * @param {Object} p1 {x, y}\r\n     * @param {Object} p2 {x, y}\r\n     * @param {Array} [props] containing x and y keys\r\n     * @return {Number} distance\r\n     */\n    function getDistance(p1, p2, props) {\n        if (!props) {\n            props = PROPS_XY;\n        }\n        var x = p2[props[0]] - p1[props[0]],\n            y = p2[props[1]] - p1[props[1]];\n\n        return Math.sqrt(x * x + y * y);\n    }\n\n    /**\r\n     * calculate the angle between two coordinates\r\n     * @param {Object} p1\r\n     * @param {Object} p2\r\n     * @param {Array} [props] containing x and y keys\r\n     * @return {Number} angle\r\n     */\n    function getAngle(p1, p2, props) {\n        if (!props) {\n            props = PROPS_XY;\n        }\n        var x = p2[props[0]] - p1[props[0]],\n            y = p2[props[1]] - p1[props[1]];\n        return Math.atan2(y, x) * 180 / Math.PI;\n    }\n\n    /**\r\n     * calculate the rotation degrees between two pointersets\r\n     * @param {Array} start array of pointers\r\n     * @param {Array} end array of pointers\r\n     * @return {Number} rotation\r\n     */\n    function getRotation(start, end) {\n        return getAngle(end[1], end[0], PROPS_CLIENT_XY) - getAngle(start[1], start[0], PROPS_CLIENT_XY);\n    }\n\n    /**\r\n     * calculate the scale factor between two pointersets\r\n     * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\r\n     * @param {Array} start array of pointers\r\n     * @param {Array} end array of pointers\r\n     * @return {Number} scale\r\n     */\n    function getScale(start, end) {\n        return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n    }\n\n    var MOUSE_INPUT_MAP = {\n        mousedown: INPUT_START,\n        mousemove: INPUT_MOVE,\n        mouseup: INPUT_END\n    };\n\n    var MOUSE_ELEMENT_EVENTS = 'mousedown';\n    var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n\n    /**\r\n     * Mouse events input\r\n     * @constructor\r\n     * @extends Input\r\n     */\n    function MouseInput() {\n        this.evEl = MOUSE_ELEMENT_EVENTS;\n        this.evWin = MOUSE_WINDOW_EVENTS;\n\n        this.allow = true; // used by Input.TouchMouse to disable mouse events\n        this.pressed = false; // mousedown state\n\n        Input.apply(this, arguments);\n    }\n\n    inherit(MouseInput, Input, {\n        /**\r\n         * handle mouse events\r\n         * @param {Object} ev\r\n         */\n        handler: function MEhandler(ev) {\n            var eventType = MOUSE_INPUT_MAP[ev.type];\n\n            // on start we want to have the left mouse button down\n            if (eventType & INPUT_START && ev.button === 0) {\n                this.pressed = true;\n            }\n\n            if (eventType & INPUT_MOVE && ev.which !== 1) {\n                eventType = INPUT_END;\n            }\n\n            // mouse must be down, and mouse events are allowed (see the TouchMouse input)\n            if (!this.pressed || !this.allow) {\n                return;\n            }\n\n            if (eventType & INPUT_END) {\n                this.pressed = false;\n            }\n\n            this.callback(this.manager, eventType, {\n                pointers: [ev],\n                changedPointers: [ev],\n                pointerType: INPUT_TYPE_MOUSE,\n                srcEvent: ev\n            });\n        }\n    });\n\n    var POINTER_INPUT_MAP = {\n        pointerdown: INPUT_START,\n        pointermove: INPUT_MOVE,\n        pointerup: INPUT_END,\n        pointercancel: INPUT_CANCEL,\n        pointerout: INPUT_CANCEL\n    };\n\n    // in IE10 the pointer types is defined as an enum\n    var IE10_POINTER_TYPE_ENUM = {\n        2: INPUT_TYPE_TOUCH,\n        3: INPUT_TYPE_PEN,\n        4: INPUT_TYPE_MOUSE,\n        5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n    };\n\n    var POINTER_ELEMENT_EVENTS = 'pointerdown';\n    var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';\n\n    // IE10 has prefixed support, and case-sensitive\n    if (window.MSPointerEvent) {\n        POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n        POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n    }\n\n    /**\r\n     * Pointer events input\r\n     * @constructor\r\n     * @extends Input\r\n     */\n    function PointerEventInput() {\n        this.evEl = POINTER_ELEMENT_EVENTS;\n        this.evWin = POINTER_WINDOW_EVENTS;\n\n        Input.apply(this, arguments);\n\n        this.store = this.manager.session.pointerEvents = [];\n    }\n\n    inherit(PointerEventInput, Input, {\n        /**\r\n         * handle mouse events\r\n         * @param {Object} ev\r\n         */\n        handler: function PEhandler(ev) {\n            var store = this.store;\n            var removePointer = false;\n\n            var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n            var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n            var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n\n            var isTouch = pointerType == INPUT_TYPE_TOUCH;\n\n            // get index of the event in the store\n            var storeIndex = inArray(store, ev.pointerId, 'pointerId');\n\n            // start and mouse must be down\n            if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n                if (storeIndex < 0) {\n                    store.push(ev);\n                    storeIndex = store.length - 1;\n                }\n            } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n                removePointer = true;\n            }\n\n            // it not found, so the pointer hasn't been down (so it's probably a hover)\n            if (storeIndex < 0) {\n                return;\n            }\n\n            // update the event in the store\n            store[storeIndex] = ev;\n\n            this.callback(this.manager, eventType, {\n                pointers: store,\n                changedPointers: [ev],\n                pointerType: pointerType,\n                srcEvent: ev\n            });\n\n            if (removePointer) {\n                // remove from the store\n                store.splice(storeIndex, 1);\n            }\n        }\n    });\n\n    var SINGLE_TOUCH_INPUT_MAP = {\n        touchstart: INPUT_START,\n        touchmove: INPUT_MOVE,\n        touchend: INPUT_END,\n        touchcancel: INPUT_CANCEL\n    };\n\n    var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\n    var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n    /**\r\n     * Touch events input\r\n     * @constructor\r\n     * @extends Input\r\n     */\n    function SingleTouchInput() {\n        this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n        this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n        this.started = false;\n\n        Input.apply(this, arguments);\n    }\n\n    inherit(SingleTouchInput, Input, {\n        handler: function TEhandler(ev) {\n            var type = SINGLE_TOUCH_INPUT_MAP[ev.type];\n\n            // should we handle the touch events?\n            if (type === INPUT_START) {\n                this.started = true;\n            }\n\n            if (!this.started) {\n                return;\n            }\n\n            var touches = normalizeSingleTouches.call(this, ev, type);\n\n            // when done, reset the started state\n            if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n                this.started = false;\n            }\n\n            this.callback(this.manager, type, {\n                pointers: touches[0],\n                changedPointers: touches[1],\n                pointerType: INPUT_TYPE_TOUCH,\n                srcEvent: ev\n            });\n        }\n    });\n\n    /**\r\n     * @this {TouchInput}\r\n     * @param {Object} ev\r\n     * @param {Number} type flag\r\n     * @returns {undefined|Array} [all, changed]\r\n     */\n    function normalizeSingleTouches(ev, type) {\n        var all = toArray(ev.touches);\n        var changed = toArray(ev.changedTouches);\n\n        if (type & (INPUT_END | INPUT_CANCEL)) {\n            all = uniqueArray(all.concat(changed), 'identifier', true);\n        }\n\n        return [all, changed];\n    }\n\n    var TOUCH_INPUT_MAP = {\n        touchstart: INPUT_START,\n        touchmove: INPUT_MOVE,\n        touchend: INPUT_END,\n        touchcancel: INPUT_CANCEL\n    };\n\n    var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n    /**\r\n     * Multi-user touch events input\r\n     * @constructor\r\n     * @extends Input\r\n     */\n    function TouchInput() {\n        this.evTarget = TOUCH_TARGET_EVENTS;\n        this.targetIds = {};\n\n        Input.apply(this, arguments);\n    }\n\n    inherit(TouchInput, Input, {\n        handler: function MTEhandler(ev) {\n            var type = TOUCH_INPUT_MAP[ev.type];\n            var touches = getTouches.call(this, ev, type);\n            if (!touches) {\n                return;\n            }\n\n            this.callback(this.manager, type, {\n                pointers: touches[0],\n                changedPointers: touches[1],\n                pointerType: INPUT_TYPE_TOUCH,\n                srcEvent: ev\n            });\n        }\n    });\n\n    /**\r\n     * @this {TouchInput}\r\n     * @param {Object} ev\r\n     * @param {Number} type flag\r\n     * @returns {undefined|Array} [all, changed]\r\n     */\n    function getTouches(ev, type) {\n        var allTouches = toArray(ev.touches);\n        var targetIds = this.targetIds;\n\n        // when there is only one touch, the process can be simplified\n        if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n            targetIds[allTouches[0].identifier] = true;\n            return [allTouches, allTouches];\n        }\n\n        var i,\n            targetTouches,\n            changedTouches = toArray(ev.changedTouches),\n            changedTargetTouches = [],\n            target = this.target;\n\n        // get target touches from touches\n        targetTouches = allTouches.filter(function (touch) {\n            return hasParent(touch.target, target);\n        });\n\n        // collect touches\n        if (type === INPUT_START) {\n            i = 0;\n            while (i < targetTouches.length) {\n                targetIds[targetTouches[i].identifier] = true;\n                i++;\n            }\n        }\n\n        // filter changed touches to only contain touches that exist in the collected target ids\n        i = 0;\n        while (i < changedTouches.length) {\n            if (targetIds[changedTouches[i].identifier]) {\n                changedTargetTouches.push(changedTouches[i]);\n            }\n\n            // cleanup removed touches\n            if (type & (INPUT_END | INPUT_CANCEL)) {\n                delete targetIds[changedTouches[i].identifier];\n            }\n            i++;\n        }\n\n        if (!changedTargetTouches.length) {\n            return;\n        }\n\n        return [\n        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];\n    }\n\n    /**\r\n     * Combined touch and mouse input\r\n     *\r\n     * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\r\n     * This because touch devices also emit mouse events while doing a touch.\r\n     *\r\n     * @constructor\r\n     * @extends Input\r\n     */\n    function TouchMouseInput() {\n        Input.apply(this, arguments);\n\n        var handler = bindFn(this.handler, this);\n        this.touch = new TouchInput(this.manager, handler);\n        this.mouse = new MouseInput(this.manager, handler);\n    }\n\n    inherit(TouchMouseInput, Input, {\n        /**\r\n         * handle mouse and touch events\r\n         * @param {Hammer} manager\r\n         * @param {String} inputEvent\r\n         * @param {Object} inputData\r\n         */\n        handler: function TMEhandler(manager, inputEvent, inputData) {\n            var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH,\n                isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;\n\n            // when we're in a touch event, so  block all upcoming mouse events\n            // most mobile browser also emit mouseevents, right after touchstart\n            if (isTouch) {\n                this.mouse.allow = false;\n            } else if (isMouse && !this.mouse.allow) {\n                return;\n            }\n\n            // reset the allowMouse when we're done\n            if (inputEvent & (INPUT_END | INPUT_CANCEL)) {\n                this.mouse.allow = true;\n            }\n\n            this.callback(manager, inputEvent, inputData);\n        },\n\n        /**\r\n         * remove the event listeners\r\n         */\n        destroy: function destroy() {\n            this.touch.destroy();\n            this.mouse.destroy();\n        }\n    });\n\n    var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\n    var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\n\n    // magical touchAction value\n    var TOUCH_ACTION_COMPUTE = 'compute';\n    var TOUCH_ACTION_AUTO = 'auto';\n    var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\n    var TOUCH_ACTION_NONE = 'none';\n    var TOUCH_ACTION_PAN_X = 'pan-x';\n    var TOUCH_ACTION_PAN_Y = 'pan-y';\n\n    /**\r\n     * Touch Action\r\n     * sets the touchAction property or uses the js alternative\r\n     * @param {Manager} manager\r\n     * @param {String} value\r\n     * @constructor\r\n     */\n    function TouchAction(manager, value) {\n        this.manager = manager;\n        this.set(value);\n    }\n\n    TouchAction.prototype = {\n        /**\r\n         * set the touchAction value on the element or enable the polyfill\r\n         * @param {String} value\r\n         */\n        set: function set(value) {\n            // find out the touch-action by the event handlers\n            if (value == TOUCH_ACTION_COMPUTE) {\n                value = this.compute();\n            }\n\n            if (NATIVE_TOUCH_ACTION) {\n                this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n            }\n            this.actions = value.toLowerCase().trim();\n        },\n\n        /**\r\n         * just re-set the touchAction value\r\n         */\n        update: function update() {\n            this.set(this.manager.options.touchAction);\n        },\n\n        /**\r\n         * compute the value for the touchAction property based on the recognizer's settings\r\n         * @returns {String} value\r\n         */\n        compute: function compute() {\n            var actions = [];\n            each(this.manager.recognizers, function (recognizer) {\n                if (boolOrFn(recognizer.options.enable, [recognizer])) {\n                    actions = actions.concat(recognizer.getTouchAction());\n                }\n            });\n            return cleanTouchActions(actions.join(' '));\n        },\n\n        /**\r\n         * this method is called on each input cycle and provides the preventing of the browser behavior\r\n         * @param {Object} input\r\n         */\n        preventDefaults: function preventDefaults(input) {\n            // not needed with native support for the touchAction property\n            if (NATIVE_TOUCH_ACTION) {\n                return;\n            }\n\n            var srcEvent = input.srcEvent;\n            var direction = input.offsetDirection;\n\n            // if the touch action did prevented once this session\n            if (this.manager.session.prevented) {\n                srcEvent.preventDefault();\n                return;\n            }\n\n            var actions = this.actions;\n            var hasNone = inStr(actions, TOUCH_ACTION_NONE);\n            var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\n            var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n\n            if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {\n                return this.preventSrc(srcEvent);\n            }\n        },\n\n        /**\r\n         * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\r\n         * @param {Object} srcEvent\r\n         */\n        preventSrc: function preventSrc(srcEvent) {\n            this.manager.session.prevented = true;\n            srcEvent.preventDefault();\n        }\n    };\n\n    /**\r\n     * when the touchActions are collected they are not a valid value, so we need to clean things up. *\r\n     * @param {String} actions\r\n     * @returns {*}\r\n     */\n    function cleanTouchActions(actions) {\n        // none\n        if (inStr(actions, TOUCH_ACTION_NONE)) {\n            return TOUCH_ACTION_NONE;\n        }\n\n        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\n\n        // pan-x and pan-y can be combined\n        if (hasPanX && hasPanY) {\n            return TOUCH_ACTION_PAN_X + ' ' + TOUCH_ACTION_PAN_Y;\n        }\n\n        // pan-x OR pan-y\n        if (hasPanX || hasPanY) {\n            return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n        }\n\n        // manipulation\n        if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n            return TOUCH_ACTION_MANIPULATION;\n        }\n\n        return TOUCH_ACTION_AUTO;\n    }\n\n    /**\r\n     * Recognizer flow explained; *\r\n     * All recognizers have the initial state of POSSIBLE when a input session starts.\r\n     * The definition of a input session is from the first input until the last input, with all it's movement in it. *\r\n     * Example session for mouse-input: mousedown -> mousemove -> mouseup\r\n     *\r\n     * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\r\n     * which determines with state it should be.\r\n     *\r\n     * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\r\n     * POSSIBLE to give it another change on the next cycle.\r\n     *\r\n     *               Possible\r\n     *                  |\r\n     *            +-----+---------------+\r\n     *            |                     |\r\n     *      +-----+-----+               |\r\n     *      |           |               |\r\n     *   Failed      Cancelled          |\r\n     *                          +-------+------+\r\n     *                          |              |\r\n     *                      Recognized       Began\r\n     *                                         |\r\n     *                                      Changed\r\n     *                                         |\r\n     *                                  Ended/Recognized\r\n     */\n    var STATE_POSSIBLE = 1;\n    var STATE_BEGAN = 2;\n    var STATE_CHANGED = 4;\n    var STATE_ENDED = 8;\n    var STATE_RECOGNIZED = STATE_ENDED;\n    var STATE_CANCELLED = 16;\n    var STATE_FAILED = 32;\n\n    /**\r\n     * Recognizer\r\n     * Every recognizer needs to extend from this class.\r\n     * @constructor\r\n     * @param {Object} options\r\n     */\n    function Recognizer(options) {\n        this.id = uniqueId();\n\n        this.manager = null;\n        this.options = merge(options || {}, this.defaults);\n\n        // default is enable true\n        this.options.enable = ifUndefined(this.options.enable, true);\n\n        this.state = STATE_POSSIBLE;\n\n        this.simultaneous = {};\n        this.requireFail = [];\n    }\n\n    Recognizer.prototype = {\n        /**\r\n         * @virtual\r\n         * @type {Object}\r\n         */\n        defaults: {},\n\n        /**\r\n         * set options\r\n         * @param {Object} options\r\n         * @return {Recognizer}\r\n         */\n        set: function set(options) {\n            extend(this.options, options);\n\n            // also update the touchAction, in case something changed about the directions/enabled state\n            this.manager && this.manager.touchAction.update();\n            return this;\n        },\n\n        /**\r\n         * recognize simultaneous with an other recognizer.\r\n         * @param {Recognizer} otherRecognizer\r\n         * @returns {Recognizer} this\r\n         */\n        recognizeWith: function recognizeWith(otherRecognizer) {\n            if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n                return this;\n            }\n\n            var simultaneous = this.simultaneous;\n            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n            if (!simultaneous[otherRecognizer.id]) {\n                simultaneous[otherRecognizer.id] = otherRecognizer;\n                otherRecognizer.recognizeWith(this);\n            }\n            return this;\n        },\n\n        /**\r\n         * drop the simultaneous link. it doesnt remove the link on the other recognizer.\r\n         * @param {Recognizer} otherRecognizer\r\n         * @returns {Recognizer} this\r\n         */\n        dropRecognizeWith: function dropRecognizeWith(otherRecognizer) {\n            if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n                return this;\n            }\n\n            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n            delete this.simultaneous[otherRecognizer.id];\n            return this;\n        },\n\n        /**\r\n         * recognizer can only run when an other is failing\r\n         * @param {Recognizer} otherRecognizer\r\n         * @returns {Recognizer} this\r\n         */\n        requireFailure: function requireFailure(otherRecognizer) {\n            if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n                return this;\n            }\n\n            var requireFail = this.requireFail;\n            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n            if (inArray(requireFail, otherRecognizer) === -1) {\n                requireFail.push(otherRecognizer);\n                otherRecognizer.requireFailure(this);\n            }\n            return this;\n        },\n\n        /**\r\n         * drop the requireFailure link. it does not remove the link on the other recognizer.\r\n         * @param {Recognizer} otherRecognizer\r\n         * @returns {Recognizer} this\r\n         */\n        dropRequireFailure: function dropRequireFailure(otherRecognizer) {\n            if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n                return this;\n            }\n\n            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n            var index = inArray(this.requireFail, otherRecognizer);\n            if (index > -1) {\n                this.requireFail.splice(index, 1);\n            }\n            return this;\n        },\n\n        /**\r\n         * has require failures boolean\r\n         * @returns {boolean}\r\n         */\n        hasRequireFailures: function hasRequireFailures() {\n            return this.requireFail.length > 0;\n        },\n\n        /**\r\n         * if the recognizer can recognize simultaneous with an other recognizer\r\n         * @param {Recognizer} otherRecognizer\r\n         * @returns {Boolean}\r\n         */\n        canRecognizeWith: function canRecognizeWith(otherRecognizer) {\n            return !!this.simultaneous[otherRecognizer.id];\n        },\n\n        /**\r\n         * You should use `tryEmit` instead of `emit` directly to check\r\n         * that all the needed recognizers has failed before emitting.\r\n         * @param {Object} input\r\n         */\n        emit: function emit(input) {\n            var self = this;\n            var state = this.state;\n\n            function emit(withState) {\n                self.manager.emit(self.options.event + (withState ? stateStr(state) : ''), input);\n            }\n\n            // 'panstart' and 'panmove'\n            if (state < STATE_ENDED) {\n                emit(true);\n            }\n\n            emit(); // simple 'eventName' events\n\n            // panend and pancancel\n            if (state >= STATE_ENDED) {\n                emit(true);\n            }\n        },\n\n        /**\r\n         * Check that all the require failure recognizers has failed,\r\n         * if true, it emits a gesture event,\r\n         * otherwise, setup the state to FAILED.\r\n         * @param {Object} input\r\n         */\n        tryEmit: function tryEmit(input) {\n            if (this.canEmit()) {\n                return this.emit(input);\n            }\n            // it's failing anyway\n            this.state = STATE_FAILED;\n        },\n\n        /**\r\n         * can we emit?\r\n         * @returns {boolean}\r\n         */\n        canEmit: function canEmit() {\n            var i = 0;\n            while (i < this.requireFail.length) {\n                if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n                    return false;\n                }\n                i++;\n            }\n            return true;\n        },\n\n        /**\r\n         * update the recognizer\r\n         * @param {Object} inputData\r\n         */\n        recognize: function recognize(inputData) {\n            // make a new copy of the inputData\n            // so we can change the inputData without messing up the other recognizers\n            var inputDataClone = extend({}, inputData);\n\n            // is is enabled and allow recognizing?\n            if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n                this.reset();\n                this.state = STATE_FAILED;\n                return;\n            }\n\n            // reset when we've reached the end\n            if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n                this.state = STATE_POSSIBLE;\n            }\n\n            this.state = this.process(inputDataClone);\n\n            // the recognizer has recognized a gesture\n            // so trigger an event\n            if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n                this.tryEmit(inputDataClone);\n            }\n        },\n\n        /**\r\n         * return the state of the recognizer\r\n         * the actual recognizing happens in this method\r\n         * @virtual\r\n         * @param {Object} inputData\r\n         * @returns {Const} STATE\r\n         */\n        process: function process(inputData) {}, // jshint ignore:line\n\n        /**\r\n         * return the preferred touch-action\r\n         * @virtual\r\n         * @returns {Array}\r\n         */\n        getTouchAction: function getTouchAction() {},\n\n        /**\r\n         * called when the gesture isn't allowed to recognize\r\n         * like when another is being recognized or it is disabled\r\n         * @virtual\r\n         */\n        reset: function reset() {}\n    };\n\n    /**\r\n     * get a usable string, used as event postfix\r\n     * @param {Const} state\r\n     * @returns {String} state\r\n     */\n    function stateStr(state) {\n        if (state & STATE_CANCELLED) {\n            return 'cancel';\n        } else if (state & STATE_ENDED) {\n            return 'end';\n        } else if (state & STATE_CHANGED) {\n            return 'move';\n        } else if (state & STATE_BEGAN) {\n            return 'start';\n        }\n        return '';\n    }\n\n    /**\r\n     * direction cons to string\r\n     * @param {Const} direction\r\n     * @returns {String}\r\n     */\n    function directionStr(direction) {\n        if (direction == DIRECTION_DOWN) {\n            return 'down';\n        } else if (direction == DIRECTION_UP) {\n            return 'up';\n        } else if (direction == DIRECTION_LEFT) {\n            return 'left';\n        } else if (direction == DIRECTION_RIGHT) {\n            return 'right';\n        }\n        return '';\n    }\n\n    /**\r\n     * get a recognizer by name if it is bound to a manager\r\n     * @param {Recognizer|String} otherRecognizer\r\n     * @param {Recognizer} recognizer\r\n     * @returns {Recognizer}\r\n     */\n    function getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n        var manager = recognizer.manager;\n        if (manager) {\n            return manager.get(otherRecognizer);\n        }\n        return otherRecognizer;\n    }\n\n    /**\r\n     * This recognizer is just used as a base for the simple attribute recognizers.\r\n     * @constructor\r\n     * @extends Recognizer\r\n     */\n    function AttrRecognizer() {\n        Recognizer.apply(this, arguments);\n    }\n\n    inherit(AttrRecognizer, Recognizer, {\n        /**\r\n         * @namespace\r\n         * @memberof AttrRecognizer\r\n         */\n        defaults: {\n            /**\r\n             * @type {Number}\r\n             * @default 1\r\n             */\n            pointers: 1\n        },\n\n        /**\r\n         * Used to check if it the recognizer receives valid input, like input.distance > 10.\r\n         * @memberof AttrRecognizer\r\n         * @param {Object} input\r\n         * @returns {Boolean} recognized\r\n         */\n        attrTest: function attrTest(input) {\n            var optionPointers = this.options.pointers;\n            return optionPointers === 0 || input.pointers.length === optionPointers;\n        },\n\n        /**\r\n         * Process the input and return the state for the recognizer\r\n         * @memberof AttrRecognizer\r\n         * @param {Object} input\r\n         * @returns {*} State\r\n         */\n        process: function process(input) {\n            var state = this.state;\n            var eventType = input.eventType;\n\n            var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n            var isValid = this.attrTest(input);\n\n            // on cancel input and we've recognized before, return STATE_CANCELLED\n            if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n                return state | STATE_CANCELLED;\n            } else if (isRecognized || isValid) {\n                if (eventType & INPUT_END) {\n                    return state | STATE_ENDED;\n                } else if (!(state & STATE_BEGAN)) {\n                    return STATE_BEGAN;\n                }\n                return state | STATE_CHANGED;\n            }\n            return STATE_FAILED;\n        }\n    });\n\n    /**\r\n     * Pan\r\n     * Recognized when the pointer is down and moved in the allowed direction.\r\n     * @constructor\r\n     * @extends AttrRecognizer\r\n     */\n    function PanRecognizer() {\n        AttrRecognizer.apply(this, arguments);\n\n        this.pX = null;\n        this.pY = null;\n    }\n\n    inherit(PanRecognizer, AttrRecognizer, {\n        /**\r\n         * @namespace\r\n         * @memberof PanRecognizer\r\n         */\n        defaults: {\n            event: 'pan',\n            threshold: 10,\n            pointers: 1,\n            direction: DIRECTION_ALL\n        },\n\n        getTouchAction: function getTouchAction() {\n            var direction = this.options.direction;\n            var actions = [];\n            if (direction & DIRECTION_HORIZONTAL) {\n                actions.push(TOUCH_ACTION_PAN_Y);\n            }\n            if (direction & DIRECTION_VERTICAL) {\n                actions.push(TOUCH_ACTION_PAN_X);\n            }\n            return actions;\n        },\n\n        directionTest: function directionTest(input) {\n            var options = this.options;\n            var hasMoved = true;\n            var distance = input.distance;\n            var direction = input.direction;\n            var x = input.deltaX;\n            var y = input.deltaY;\n\n            // lock to axis?\n            if (!(direction & options.direction)) {\n                if (options.direction & DIRECTION_HORIZONTAL) {\n                    direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n                    hasMoved = x != this.pX;\n                    distance = Math.abs(input.deltaX);\n                } else {\n                    direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n                    hasMoved = y != this.pY;\n                    distance = Math.abs(input.deltaY);\n                }\n            }\n            input.direction = direction;\n            return hasMoved && distance > options.threshold && direction & options.direction;\n        },\n\n        attrTest: function attrTest(input) {\n            return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));\n        },\n\n        emit: function emit(input) {\n            this.pX = input.deltaX;\n            this.pY = input.deltaY;\n\n            var direction = directionStr(input.direction);\n            if (direction) {\n                this.manager.emit(this.options.event + direction, input);\n            }\n\n            this._super.emit.call(this, input);\n        }\n    });\n\n    /**\r\n     * Pinch\r\n     * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\r\n     * @constructor\r\n     * @extends AttrRecognizer\r\n     */\n    function PinchRecognizer() {\n        AttrRecognizer.apply(this, arguments);\n    }\n\n    inherit(PinchRecognizer, AttrRecognizer, {\n        /**\r\n         * @namespace\r\n         * @memberof PinchRecognizer\r\n         */\n        defaults: {\n            event: 'pinch',\n            threshold: 0,\n            pointers: 2\n        },\n\n        getTouchAction: function getTouchAction() {\n            return [TOUCH_ACTION_NONE];\n        },\n\n        attrTest: function attrTest(input) {\n            return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n        },\n\n        emit: function emit(input) {\n            this._super.emit.call(this, input);\n            if (input.scale !== 1) {\n                var inOut = input.scale < 1 ? 'in' : 'out';\n                this.manager.emit(this.options.event + inOut, input);\n            }\n        }\n    });\n\n    /**\r\n     * Press\r\n     * Recognized when the pointer is down for x ms without any movement.\r\n     * @constructor\r\n     * @extends Recognizer\r\n     */\n    function PressRecognizer() {\n        Recognizer.apply(this, arguments);\n\n        this._timer = null;\n        this._input = null;\n    }\n\n    inherit(PressRecognizer, Recognizer, {\n        /**\r\n         * @namespace\r\n         * @memberof PressRecognizer\r\n         */\n        defaults: {\n            event: 'press',\n            pointers: 1,\n            time: 500, // minimal time of the pointer to be pressed\n            threshold: 5 // a minimal movement is ok, but keep it low\n        },\n\n        getTouchAction: function getTouchAction() {\n            return [TOUCH_ACTION_AUTO];\n        },\n\n        process: function process(input) {\n            var options = this.options;\n            var validPointers = input.pointers.length === options.pointers;\n            var validMovement = input.distance < options.threshold;\n            var validTime = input.deltaTime > options.time;\n\n            this._input = input;\n\n            // we only allow little movement\n            // and we've reached an end event, so a tap is possible\n            if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {\n                this.reset();\n            } else if (input.eventType & INPUT_START) {\n                this.reset();\n                this._timer = setTimeoutContext(function () {\n                    this.state = STATE_RECOGNIZED;\n                    this.tryEmit();\n                }, options.time, this);\n            } else if (input.eventType & INPUT_END) {\n                return STATE_RECOGNIZED;\n            }\n            return STATE_FAILED;\n        },\n\n        reset: function reset() {\n            clearTimeout(this._timer);\n        },\n\n        emit: function emit(input) {\n            if (this.state !== STATE_RECOGNIZED) {\n                return;\n            }\n\n            if (input && input.eventType & INPUT_END) {\n                this.manager.emit(this.options.event + 'up', input);\n            } else {\n                this._input.timeStamp = now();\n                this.manager.emit(this.options.event, this._input);\n            }\n        }\n    });\n\n    /**\r\n     * Rotate\r\n     * Recognized when two or more pointer are moving in a circular motion.\r\n     * @constructor\r\n     * @extends AttrRecognizer\r\n     */\n    function RotateRecognizer() {\n        AttrRecognizer.apply(this, arguments);\n    }\n\n    inherit(RotateRecognizer, AttrRecognizer, {\n        /**\r\n         * @namespace\r\n         * @memberof RotateRecognizer\r\n         */\n        defaults: {\n            event: 'rotate',\n            threshold: 0,\n            pointers: 2\n        },\n\n        getTouchAction: function getTouchAction() {\n            return [TOUCH_ACTION_NONE];\n        },\n\n        attrTest: function attrTest(input) {\n            return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n        }\n    });\n\n    /**\r\n     * Swipe\r\n     * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\r\n     * @constructor\r\n     * @extends AttrRecognizer\r\n     */\n    function SwipeRecognizer() {\n        AttrRecognizer.apply(this, arguments);\n    }\n\n    inherit(SwipeRecognizer, AttrRecognizer, {\n        /**\r\n         * @namespace\r\n         * @memberof SwipeRecognizer\r\n         */\n        defaults: {\n            event: 'swipe',\n            threshold: 10,\n            velocity: 0.65,\n            direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n            pointers: 1\n        },\n\n        getTouchAction: function getTouchAction() {\n            return PanRecognizer.prototype.getTouchAction.call(this);\n        },\n\n        attrTest: function attrTest(input) {\n            var direction = this.options.direction;\n            var velocity;\n\n            if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n                velocity = input.velocity;\n            } else if (direction & DIRECTION_HORIZONTAL) {\n                velocity = input.velocityX;\n            } else if (direction & DIRECTION_VERTICAL) {\n                velocity = input.velocityY;\n            }\n\n            return this._super.attrTest.call(this, input) && direction & input.direction && input.distance > this.options.threshold && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n        },\n\n        emit: function emit(input) {\n            var direction = directionStr(input.direction);\n            if (direction) {\n                this.manager.emit(this.options.event + direction, input);\n            }\n\n            this.manager.emit(this.options.event, input);\n        }\n    });\n\n    /**\r\n     * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\r\n     * between the given interval and position. The delay option can be used to recognize multi-taps without firing\r\n     * a single tap.\r\n     *\r\n     * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\r\n     * multi-taps being recognized.\r\n     * @constructor\r\n     * @extends Recognizer\r\n     */\n    function TapRecognizer() {\n        Recognizer.apply(this, arguments);\n\n        // previous time and center,\n        // used for tap counting\n        this.pTime = false;\n        this.pCenter = false;\n\n        this._timer = null;\n        this._input = null;\n        this.count = 0;\n    }\n\n    inherit(TapRecognizer, Recognizer, {\n        /**\r\n         * @namespace\r\n         * @memberof PinchRecognizer\r\n         */\n        defaults: {\n            event: 'tap',\n            pointers: 1,\n            taps: 1,\n            interval: 300, // max time between the multi-tap taps\n            time: 250, // max time of the pointer to be down (like finger on the screen)\n            threshold: 2, // a minimal movement is ok, but keep it low\n            posThreshold: 10 // a multi-tap can be a bit off the initial position\n        },\n\n        getTouchAction: function getTouchAction() {\n            return [TOUCH_ACTION_MANIPULATION];\n        },\n\n        process: function process(input) {\n            var options = this.options;\n\n            var validPointers = input.pointers.length === options.pointers;\n            var validMovement = input.distance < options.threshold;\n            var validTouchTime = input.deltaTime < options.time;\n\n            this.reset();\n\n            if (input.eventType & INPUT_START && this.count === 0) {\n                return this.failTimeout();\n            }\n\n            // we only allow little movement\n            // and we've reached an end event, so a tap is possible\n            if (validMovement && validTouchTime && validPointers) {\n                if (input.eventType != INPUT_END) {\n                    return this.failTimeout();\n                }\n\n                var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;\n                var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n\n                this.pTime = input.timeStamp;\n                this.pCenter = input.center;\n\n                if (!validMultiTap || !validInterval) {\n                    this.count = 1;\n                } else {\n                    this.count += 1;\n                }\n\n                this._input = input;\n\n                // if tap count matches we have recognized it,\n                // else it has began recognizing...\n                var tapCount = this.count % options.taps;\n                if (tapCount === 0) {\n                    // no failing requirements, immediately trigger the tap event\n                    // or wait as long as the multitap interval to trigger\n                    if (!this.hasRequireFailures()) {\n                        return STATE_RECOGNIZED;\n                    } else {\n                        this._timer = setTimeoutContext(function () {\n                            this.state = STATE_RECOGNIZED;\n                            this.tryEmit();\n                        }, options.interval, this);\n                        return STATE_BEGAN;\n                    }\n                }\n            }\n            return STATE_FAILED;\n        },\n\n        failTimeout: function failTimeout() {\n            this._timer = setTimeoutContext(function () {\n                this.state = STATE_FAILED;\n            }, this.options.interval, this);\n            return STATE_FAILED;\n        },\n\n        reset: function reset() {\n            clearTimeout(this._timer);\n        },\n\n        emit: function emit() {\n            if (this.state == STATE_RECOGNIZED) {\n                this._input.tapCount = this.count;\n                this.manager.emit(this.options.event, this._input);\n            }\n        }\n    });\n\n    /**\r\n     * Simple way to create an manager with a default set of recognizers.\r\n     * @param {HTMLElement} element\r\n     * @param {Object} [options]\r\n     * @constructor\r\n     */\n    function Hammer(element, options) {\n        options = options || {};\n        options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);\n        return new Manager(element, options);\n    }\n\n    /**\r\n     * @const {string}\r\n     */\n    Hammer.VERSION = '2.0.4';\n\n    /**\r\n     * default settings\r\n     * @namespace\r\n     */\n    Hammer.defaults = {\n        /**\r\n         * set if DOM events are being triggered.\r\n         * But this is slower and unused by simple implementations, so disabled by default.\r\n         * @type {Boolean}\r\n         * @default false\r\n         */\n        domEvents: false,\n\n        /**\r\n         * The value for the touchAction property/fallback.\r\n         * When set to `compute` it will magically set the correct value based on the added recognizers.\r\n         * @type {String}\r\n         * @default compute\r\n         */\n        touchAction: TOUCH_ACTION_COMPUTE,\n\n        /**\r\n         * @type {Boolean}\r\n         * @default true\r\n         */\n        enable: true,\n\n        /**\r\n         * EXPERIMENTAL FEATURE -- can be removed/changed\r\n         * Change the parent input target element.\r\n         * If Null, then it is being set the to main element.\r\n         * @type {Null|EventTarget}\r\n         * @default null\r\n         */\n        inputTarget: null,\n\n        /**\r\n         * force an input class\r\n         * @type {Null|Function}\r\n         * @default null\r\n         */\n        inputClass: null,\n\n        /**\r\n         * Default recognizer setup when calling `Hammer()`\r\n         * When creating a new Manager these will be skipped.\r\n         * @type {Array}\r\n         */\n        preset: [\n        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\n        [RotateRecognizer, { enable: false }], [PinchRecognizer, { enable: false }, ['rotate']], [SwipeRecognizer, { direction: DIRECTION_HORIZONTAL }], [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ['swipe']], [TapRecognizer], [TapRecognizer, { event: 'doubletap', taps: 2 }, ['tap']], [PressRecognizer]],\n\n        /**\r\n         * Some CSS properties can be used to improve the working of Hammer.\r\n         * Add them to this method and they will be set when creating a new Manager.\r\n         * @namespace\r\n         */\n        cssProps: {\n            /**\r\n             * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\r\n             * @type {String}\r\n             * @default 'none'\r\n             */\n            userSelect: 'none',\n\n            /**\r\n             * Disable the Windows Phone grippers when pressing an element.\r\n             * @type {String}\r\n             * @default 'none'\r\n             */\n            touchSelect: 'none',\n\n            /**\r\n             * Disables the default callout shown when you touch and hold a touch target.\r\n             * On iOS, when you touch and hold a touch target such as a link, Safari displays\r\n             * a callout containing information about the link. This property allows you to disable that callout.\r\n             * @type {String}\r\n             * @default 'none'\r\n             */\n            touchCallout: 'none',\n\n            /**\r\n             * Specifies whether zooming is enabled. Used by IE10>\r\n             * @type {String}\r\n             * @default 'none'\r\n             */\n            contentZooming: 'none',\n\n            /**\r\n             * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\r\n             * @type {String}\r\n             * @default 'none'\r\n             */\n            userDrag: 'none',\n\n            /**\r\n             * Overrides the highlight color shown when the user taps a link or a JavaScript\r\n             * clickable element in iOS. This property obeys the alpha value, if specified.\r\n             * @type {String}\r\n             * @default 'rgba(0,0,0,0)'\r\n             */\n            tapHighlightColor: 'rgba(0,0,0,0)'\n        }\n    };\n\n    var STOP = 1;\n    var FORCED_STOP = 2;\n\n    /**\r\n     * Manager\r\n     * @param {HTMLElement} element\r\n     * @param {Object} [options]\r\n     * @constructor\r\n     */\n    function Manager(element, options) {\n        options = options || {};\n\n        this.options = merge(options, Hammer.defaults);\n        this.options.inputTarget = this.options.inputTarget || element;\n\n        this.handlers = {};\n        this.session = {};\n        this.recognizers = [];\n\n        this.element = element;\n        this.input = createInputInstance(this);\n        this.touchAction = new TouchAction(this, this.options.touchAction);\n\n        toggleCssProps(this, true);\n\n        each(options.recognizers, function (item) {\n            var recognizer = this.add(new item[0](item[1]));\n            item[2] && recognizer.recognizeWith(item[2]);\n            item[3] && recognizer.requireFailure(item[3]);\n        }, this);\n    }\n\n    Manager.prototype = {\n        /**\r\n         * set options\r\n         * @param {Object} options\r\n         * @returns {Manager}\r\n         */\n        set: function set(options) {\n            extend(this.options, options);\n\n            // Options that need a little more setup\n            if (options.touchAction) {\n                this.touchAction.update();\n            }\n            if (options.inputTarget) {\n                // Clean up existing event listeners and reinitialize\n                this.input.destroy();\n                this.input.target = options.inputTarget;\n                this.input.init();\n            }\n            return this;\n        },\n\n        /**\r\n         * stop recognizing for this session.\r\n         * This session will be discarded, when a new [input]start event is fired.\r\n         * When forced, the recognizer cycle is stopped immediately.\r\n         * @param {Boolean} [force]\r\n         */\n        stop: function stop(force) {\n            this.session.stopped = force ? FORCED_STOP : STOP;\n        },\n\n        /**\r\n         * run the recognizers!\r\n         * called by the inputHandler function on every movement of the pointers (touches)\r\n         * it walks through all the recognizers and tries to detect the gesture that is being made\r\n         * @param {Object} inputData\r\n         */\n        recognize: function recognize(inputData) {\n            var session = this.session;\n            if (session.stopped) {\n                return;\n            }\n\n            // run the touch-action polyfill\n            this.touchAction.preventDefaults(inputData);\n\n            var recognizer;\n            var recognizers = this.recognizers;\n\n            // this holds the recognizer that is being recognized.\n            // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n            // if no recognizer is detecting a thing, it is set to `null`\n            var curRecognizer = session.curRecognizer;\n\n            // reset when the last recognizer is recognized\n            // or when we're in a new session\n            if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {\n                curRecognizer = session.curRecognizer = null;\n            }\n\n            var i = 0;\n            while (i < recognizers.length) {\n                recognizer = recognizers[i];\n\n                // find out if we are allowed try to recognize the input for this one.\n                // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n                // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n                //      that is being recognized.\n                // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n                //      this can be setup with the `recognizeWith()` method on the recognizer.\n                if (session.stopped !== FORCED_STOP && ( // 1\n                !curRecognizer || recognizer == curRecognizer || // 2\n                recognizer.canRecognizeWith(curRecognizer))) {\n                    // 3\n                    recognizer.recognize(inputData);\n                } else {\n                    recognizer.reset();\n                }\n\n                // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n                // current active recognizer. but only if we don't already have an active recognizer\n                if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n                    curRecognizer = session.curRecognizer = recognizer;\n                }\n                i++;\n            }\n        },\n\n        /**\r\n         * get a recognizer by its event name.\r\n         * @param {Recognizer|String} recognizer\r\n         * @returns {Recognizer|Null}\r\n         */\n        get: function get(recognizer) {\n            if (recognizer instanceof Recognizer) {\n                return recognizer;\n            }\n\n            var recognizers = this.recognizers;\n            for (var i = 0; i < recognizers.length; i++) {\n                if (recognizers[i].options.event == recognizer) {\n                    return recognizers[i];\n                }\n            }\n            return null;\n        },\n\n        /**\r\n         * add a recognizer to the manager\r\n         * existing recognizers with the same event name will be removed\r\n         * @param {Recognizer} recognizer\r\n         * @returns {Recognizer|Manager}\r\n         */\n        add: function add(recognizer) {\n            if (invokeArrayArg(recognizer, 'add', this)) {\n                return this;\n            }\n\n            // remove existing\n            var existing = this.get(recognizer.options.event);\n            if (existing) {\n                this.remove(existing);\n            }\n\n            this.recognizers.push(recognizer);\n            recognizer.manager = this;\n\n            this.touchAction.update();\n            return recognizer;\n        },\n\n        /**\r\n         * remove a recognizer by name or instance\r\n         * @param {Recognizer|String} recognizer\r\n         * @returns {Manager}\r\n         */\n        remove: function remove(recognizer) {\n            if (invokeArrayArg(recognizer, 'remove', this)) {\n                return this;\n            }\n\n            var recognizers = this.recognizers;\n            recognizer = this.get(recognizer);\n            recognizers.splice(inArray(recognizers, recognizer), 1);\n\n            this.touchAction.update();\n            return this;\n        },\n\n        /**\r\n         * bind event\r\n         * @param {String} events\r\n         * @param {Function} handler\r\n         * @returns {EventEmitter} this\r\n         */\n        on: function on(events, handler) {\n            var handlers = this.handlers;\n            each(splitStr(events), function (event) {\n                handlers[event] = handlers[event] || [];\n                handlers[event].push(handler);\n            });\n            return this;\n        },\n\n        /**\r\n         * unbind event, leave emit blank to remove all handlers\r\n         * @param {String} events\r\n         * @param {Function} [handler]\r\n         * @returns {EventEmitter} this\r\n         */\n        off: function off(events, handler) {\n            var handlers = this.handlers;\n            each(splitStr(events), function (event) {\n                if (!handler) {\n                    delete handlers[event];\n                } else {\n                    handlers[event].splice(inArray(handlers[event], handler), 1);\n                }\n            });\n            return this;\n        },\n\n        /**\r\n         * emit event to the listeners\r\n         * @param {String} event\r\n         * @param {Object} data\r\n         */\n        emit: function emit(event, data) {\n            // we also want to trigger dom events\n            if (this.options.domEvents) {\n                triggerDomEvent(event, data);\n            }\n\n            // no handlers, so skip it all\n            var handlers = this.handlers[event] && this.handlers[event].slice();\n            if (!handlers || !handlers.length) {\n                return;\n            }\n\n            data.type = event;\n            data.preventDefault = function () {\n                data.srcEvent.preventDefault();\n            };\n\n            var i = 0;\n            while (i < handlers.length) {\n                handlers[i](data);\n                i++;\n            }\n        },\n\n        /**\r\n         * destroy the manager and unbinds all events\r\n         * it doesn't unbind dom events, that is the user own responsibility\r\n         */\n        destroy: function destroy() {\n            this.element && toggleCssProps(this, false);\n\n            this.handlers = {};\n            this.session = {};\n            this.input.destroy();\n            this.element = null;\n        }\n    };\n\n    /**\r\n     * add/remove the css properties as defined in manager.options.cssProps\r\n     * @param {Manager} manager\r\n     * @param {Boolean} add\r\n     */\n    function toggleCssProps(manager, add) {\n        var element = manager.element;\n        each(manager.options.cssProps, function (value, name) {\n            element.style[prefixed(element.style, name)] = add ? value : '';\n        });\n    }\n\n    /**\r\n     * trigger dom event\r\n     * @param {String} event\r\n     * @param {Object} data\r\n     */\n    function triggerDomEvent(event, data) {\n        var gestureEvent = document.createEvent('Event');\n        gestureEvent.initEvent(event, true, true);\n        gestureEvent.gesture = data;\n        data.target.dispatchEvent(gestureEvent);\n    }\n\n    extend(Hammer, {\n        INPUT_START: INPUT_START,\n        INPUT_MOVE: INPUT_MOVE,\n        INPUT_END: INPUT_END,\n        INPUT_CANCEL: INPUT_CANCEL,\n\n        STATE_POSSIBLE: STATE_POSSIBLE,\n        STATE_BEGAN: STATE_BEGAN,\n        STATE_CHANGED: STATE_CHANGED,\n        STATE_ENDED: STATE_ENDED,\n        STATE_RECOGNIZED: STATE_RECOGNIZED,\n        STATE_CANCELLED: STATE_CANCELLED,\n        STATE_FAILED: STATE_FAILED,\n\n        DIRECTION_NONE: DIRECTION_NONE,\n        DIRECTION_LEFT: DIRECTION_LEFT,\n        DIRECTION_RIGHT: DIRECTION_RIGHT,\n        DIRECTION_UP: DIRECTION_UP,\n        DIRECTION_DOWN: DIRECTION_DOWN,\n        DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,\n        DIRECTION_VERTICAL: DIRECTION_VERTICAL,\n        DIRECTION_ALL: DIRECTION_ALL,\n\n        Manager: Manager,\n        Input: Input,\n        TouchAction: TouchAction,\n\n        TouchInput: TouchInput,\n        MouseInput: MouseInput,\n        PointerEventInput: PointerEventInput,\n        TouchMouseInput: TouchMouseInput,\n        SingleTouchInput: SingleTouchInput,\n\n        Recognizer: Recognizer,\n        AttrRecognizer: AttrRecognizer,\n        Tap: TapRecognizer,\n        Pan: PanRecognizer,\n        Swipe: SwipeRecognizer,\n        Pinch: PinchRecognizer,\n        Rotate: RotateRecognizer,\n        Press: PressRecognizer,\n\n        on: addEventListeners,\n        off: removeEventListeners,\n        each: each,\n        merge: merge,\n        extend: extend,\n        inherit: inherit,\n        bindFn: bindFn,\n        prefixed: prefixed\n    });\n\n    if ((typeof define === 'undefined' ? 'undefined' : _typeof(define)) == TYPE_FUNCTION && define.amd) {\n        define(function () {\n            return Hammer;\n        });\n    } else if (typeof module != 'undefined' && module.exports) {\n        module.exports = Hammer;\n    } else {\n        window[exportName] = Hammer;\n    }\n})(window, document, 'Hammer');"},{"id":3,"identifier":"/home/paul/auru/node_modules/webpack/buildin/amd-define.js","name":"(webpack)/buildin/amd-define.js","index":3,"index2":1,"size":85,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/home/paul/auru/node_modules/babel-loader/index.js!/home/paul/auru/node_modules/hammerjs/hammer.js","failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":2,"moduleIdentifier":"/home/paul/auru/node_modules/babel-loader/index.js!/home/paul/auru/node_modules/hammerjs/hammer.js","module":"./~/hammerjs/hammer.js","moduleName":"./~/hammerjs/hammer.js","type":"amd require","userRequest":{"range":[76853,76859],"loc":{"start":{"line":2445,"column":63},"end":{"line":2445,"column":69}},"type":"Identifier","name":"define"},"loc":"2445:63-69"}],"source":"module.exports = function() { throw new Error(\"define cannot be used indirect\"); };\r\n"},{"id":4,"identifier":"/home/paul/auru/node_modules/webpack/buildin/amd-options.js","name":"(webpack)/buildin/amd-options.js","index":4,"index2":2,"size":43,"cacheable":true,"built":true,"optional":false,"prefetched":false,"chunks":[0],"assets":[],"issuer":"/home/paul/auru/node_modules/babel-loader/index.js!/home/paul/auru/node_modules/hammerjs/hammer.js","failed":false,"errors":0,"warnings":0,"reasons":[{"moduleId":2,"moduleIdentifier":"/home/paul/auru/node_modules/babel-loader/index.js!/home/paul/auru/node_modules/hammerjs/hammer.js","module":"./~/hammerjs/hammer.js","moduleName":"./~/hammerjs/hammer.js","type":"amd require","userRequest":{"range":[76882,76892],"loc":{"start":{"line":2445,"column":92},"end":{"line":2445,"column":102}},"type":"MemberExpression","computed":false,"object":{"range":[76882,76888],"loc":{"start":{"line":2445,"column":92},"end":{"line":2445,"column":98}},"type":"Identifier","name":"define"},"property":{"range":[76889,76892],"loc":{"start":{"line":2445,"column":99},"end":{"line":2445,"column":102}},"type":"Identifier","name":"amd"}},"loc":"2445:92-102"}],"source":"module.exports = __webpack_amd_options__;\r\n"}],"filteredModules":0,"children":[]}