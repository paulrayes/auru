{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///auru.notouch.min.js","webpack:///webpack/bootstrap 5229cb3848dfe50baad5","webpack:///./auru.js","webpack:///./~/eventemitter3/index.js","webpack:///./~/hammerjs/hammer.js","webpack:///(webpack)/buildin/amd-define.js","webpack:///(webpack)/buildin/amd-options.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","dumbMerge","first","second","copy","key","_createClass","defineProperties","target","props","i","length","descriptor","defineProperty","protoProps","staticProps","Hammer","EventEmitter","touchEnabled","AURU_TOUCH_ENABLED","defaultOptions","slideDuration","classPrefix","continuousLoop","touch","Auru","_EventEmitter","element","options","_this2","getPrototypeOf","playing","currentIndex","maxIndex","children","previousSlide","currentSlide","_initializeClasses","_initializeTouchEvents","play","prefix","classList","add","Array","forEach","childNode","remove","_this","hammer","on","next","emit","previous","elem","timer","setInterval","bind","clearInterval","nextIndex","goToSlide","index","oldPrevious","current","oldIndex","_removeAnimationClasses","removeClasses","destroy","_removeClasses","stop","removeAllListeners","EE","fn","context","once","_events","undefined","listeners","event","exists","evt","available","l","ee","a1","a2","a3","a4","a5","args","len","arguments","removeListener","apply","j","listener","push","events","off","addListener","setMaxListeners","prefixed","_typeof","obj","Symbol","__WEBPACK_AMD_DEFINE_RESULT__","window","document","exportName","setTimeoutContext","timeout","setTimeout","bindFn","invokeArrayArg","arg","isArray","each","iterator","hasOwnProperty","extend","dest","src","merge","keys","inherit","child","base","properties","childP","baseP","_super","boolOrFn","val","TYPE_FUNCTION","ifUndefined","val1","val2","addEventListeners","types","handler","splitStr","type","addEventListener","removeEventListeners","removeEventListener","hasParent","node","parent","parentNode","inStr","str","find","indexOf","trim","split","inArray","findByKey","toArray","slice","uniqueArray","sort","results","values","a","b","property","prop","camelProp","toUpperCase","VENDOR_PREFIXES","uniqueId","_uniqueId","getWindowForElement","doc","ownerDocument","defaultView","parentWindow","Input","manager","callback","inputTarget","domHandler","ev","enable","init","createInputInstance","Type","inputClass","SUPPORT_POINTER_EVENTS","PointerEventInput","SUPPORT_ONLY_TOUCH","TouchInput","SUPPORT_TOUCH","TouchMouseInput","MouseInput","inputHandler","eventType","input","pointersLen","pointers","changedPointersLen","changedPointers","isFirst","INPUT_START","isFinal","INPUT_END","INPUT_CANCEL","session","computeInputData","recognize","prevInput","pointersLength","firstInput","simpleCloneInputData","firstMultiple","offsetCenter","center","getCenter","timeStamp","now","deltaTime","angle","getAngle","distance","getDistance","computeDeltaXY","offsetDirection","getDirection","deltaX","deltaY","scale","getScale","rotation","getRotation","computeIntervalInputData","srcEvent","offset","offsetDelta","prevDelta","x","y","velocity","velocityX","velocityY","direction","last","lastInterval","COMPUTE_INTERVAL","v","getVelocity","abs","clientX","round","clientY","DIRECTION_NONE","DIRECTION_LEFT","DIRECTION_RIGHT","DIRECTION_UP","DIRECTION_DOWN","p1","p2","PROPS_XY","Math","sqrt","atan2","PI","start","end","PROPS_CLIENT_XY","evEl","MOUSE_ELEMENT_EVENTS","evWin","MOUSE_WINDOW_EVENTS","allow","pressed","POINTER_ELEMENT_EVENTS","POINTER_WINDOW_EVENTS","store","pointerEvents","SingleTouchInput","evTarget","SINGLE_TOUCH_TARGET_EVENTS","SINGLE_TOUCH_WINDOW_EVENTS","started","normalizeSingleTouches","all","touches","changed","changedTouches","concat","TOUCH_TARGET_EVENTS","targetIds","getTouches","allTouches","INPUT_MOVE","identifier","targetTouches","changedTargetTouches","filter","mouse","TouchAction","set","cleanTouchActions","actions","TOUCH_ACTION_NONE","hasPanX","TOUCH_ACTION_PAN_X","hasPanY","TOUCH_ACTION_PAN_Y","TOUCH_ACTION_MANIPULATION","TOUCH_ACTION_AUTO","Recognizer","defaults","state","STATE_POSSIBLE","simultaneous","requireFail","stateStr","STATE_CANCELLED","STATE_ENDED","STATE_CHANGED","STATE_BEGAN","directionStr","getRecognizerByNameIfManager","otherRecognizer","recognizer","get","AttrRecognizer","PanRecognizer","pX","pY","PinchRecognizer","PressRecognizer","_timer","_input","RotateRecognizer","SwipeRecognizer","TapRecognizer","pTime","pCenter","count","recognizers","preset","Manager","handlers","touchAction","toggleCssProps","item","recognizeWith","requireFailure","cssProps","name","style","triggerDomEvent","data","gestureEvent","createEvent","initEvent","gesture","dispatchEvent","TEST_ELEMENT","createElement","Date","MOBILE_REGEX","test","navigator","userAgent","INPUT_TYPE_TOUCH","INPUT_TYPE_PEN","INPUT_TYPE_MOUSE","INPUT_TYPE_KINECT","DIRECTION_HORIZONTAL","DIRECTION_VERTICAL","DIRECTION_ALL","MOUSE_INPUT_MAP","mousedown","mousemove","mouseup","button","which","pointerType","POINTER_INPUT_MAP","pointerdown","pointermove","pointerup","pointercancel","pointerout","IE10_POINTER_TYPE_ENUM",2,3,4,5,"MSPointerEvent","removePointer","eventTypeNormalized","toLowerCase","replace","isTouch","storeIndex","pointerId","splice","SINGLE_TOUCH_INPUT_MAP","touchstart","touchmove","touchend","touchcancel","TOUCH_INPUT_MAP","inputEvent","inputData","isMouse","PREFIXED_TOUCH_ACTION","NATIVE_TOUCH_ACTION","TOUCH_ACTION_COMPUTE","compute","update","getTouchAction","join","preventDefaults","prevented","preventDefault","hasNone","preventSrc","STATE_RECOGNIZED","STATE_FAILED","dropRecognizeWith","dropRequireFailure","hasRequireFailures","canRecognizeWith","withState","tryEmit","canEmit","inputDataClone","process","reset","attrTest","optionPointers","isRecognized","isValid","threshold","directionTest","hasMoved","inOut","time","validPointers","validMovement","validTime","clearTimeout","taps","interval","posThreshold","validTouchTime","failTimeout","validInterval","validMultiTap","tapCount","VERSION","domEvents","userSelect","touchSelect","touchCallout","contentZooming","userDrag","tapHighlightColor","STOP","FORCED_STOP","force","stopped","curRecognizer","existing","Tap","Pan","Swipe","Pinch","Rotate","Press","Error","__webpack_amd_options__"],"mappings":"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","file":"auru.notouch.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Auru\"] = factory();\n\telse\n\t\troot[\"Auru\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Auru\"] = factory();\n\telse\n\t\troot[\"Auru\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar EventEmitter = __webpack_require__(2);\n\tvar Hammer;\n\tvar touchEnabled = typeof AURU_TOUCH_ENABLED === 'undefined' || AURU_TOUCH_ENABLED === true;\n\tif (touchEnabled) {\n\t\tHammer = __webpack_require__(3);\n\t}\n\t\n\tvar defaultOptions = {\n\t\tslideDuration: 5, // how many seconds to show each slide, false to not play automatically\n\t\tclassPrefix: 'auru-',\n\t\tcontinuousLoop: true,\n\t\ttouch: false\n\t};\n\t\n\tfunction dumbMerge(first, second) {\n\t\tvar copy = {};\n\t\tfor (var key in first) {\n\t\t\tcopy[key] = first[key];\n\t\t}\n\t\tfor (var key in second) {\n\t\t\tcopy[key] = second[key];\n\t\t}\n\t\treturn copy;\n\t}\n\t\n\tvar Auru = (function (_EventEmitter) {\n\t\t_inherits(Auru, _EventEmitter);\n\t\n\t\tfunction Auru(element, options) {\n\t\t\t_classCallCheck(this, Auru);\n\t\n\t\t\tvar _this2 = _possibleConstructorReturn(this, Object.getPrototypeOf(Auru).call(this));\n\t\n\t\t\t_this2.element = element;\n\t\t\t_this2.options = dumbMerge(defaultOptions, options || {});\n\t\n\t\t\t_this2.playing = false;\n\t\t\t_this2.currentIndex = 0;\n\t\t\t_this2.maxIndex = _this2.element.children.length - 1;\n\t\t\t_this2.previousSlide = _this2.element.children[_this2.maxIndex];\n\t\t\t_this2.currentSlide = _this2.element.children[_this2.currentIndex];\n\t\n\t\t\t_this2._initializeClasses();\n\t\n\t\t\tif (touchEnabled && _this2.options.touch) {\n\t\t\t\t_this2._initializeTouchEvents();\n\t\t\t}\n\t\n\t\t\tif (_this2.options.slideDuration) {\n\t\t\t\t_this2.play();\n\t\t\t}\n\t\t\treturn _this2;\n\t\t}\n\t\n\t\t_createClass(Auru, [{\n\t\t\tkey: '_initializeClasses',\n\t\t\tvalue: function _initializeClasses() {\n\t\t\t\tvar prefix = this.options.classPrefix,\n\t\t\t\t    i = 0;\n\t\t\t\tthis.element.classList.add(prefix + 'slideshow');\n\t\t\t\tArray.prototype.forEach.call(this.element.children, function (childNode) {\n\t\t\t\t\tchildNode.classList.add(prefix + 'slide');\n\t\t\t\t\tif (i === 0) {\n\t\t\t\t\t\tchildNode.classList.add(prefix + 'current');\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchildNode.classList.add(prefix + 'hidden');\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t});\n\t\t\t}\n\t\t}, {\n\t\t\tkey: '_removeClasses',\n\t\t\tvalue: function _removeClasses() {\n\t\t\t\tvar prefix = this.options.classPrefix,\n\t\t\t\t    i = 0;\n\t\t\t\tthis.element.classList.remove(prefix + 'slideshow');\n\t\t\t\tArray.prototype.forEach.call(this.element.children, function (childNode) {\n\t\t\t\t\tchildNode.classList.remove(prefix + 'slide', prefix + 'current', prefix + 'previous', prefix + 'to-right', prefix + 'to-left', prefix + 'from-right', prefix + 'from-left');\n\t\t\t\t\ti++;\n\t\t\t\t});\n\t\t\t}\n\t\t}, {\n\t\t\tkey: '_initializeTouchEvents',\n\t\t\tvalue: function _initializeTouchEvents() {\n\t\t\t\tvar _this = this;\n\t\n\t\t\t\tthis.hammer = new Hammer(this.element);\n\t\t\t\tthis.hammer.on('swipeleft', function () {\n\t\t\t\t\t_this.next();\n\t\t\t\t\t_this.emit('swipe');\n\t\t\t\t\t_this.emit('swipeleft');\n\t\t\t\t});\n\t\t\t\tthis.hammer.on('swiperight', function () {\n\t\t\t\t\t_this.previous();\n\t\t\t\t\t_this.emit('swipe');\n\t\t\t\t\t_this.emit('swiperight');\n\t\t\t\t});\n\t\t\t\tthis.hammer.on('tap', function () {\n\t\t\t\t\t_this.emit('tap');\n\t\t\t\t});\n\t\t\t}\n\t\t}, {\n\t\t\tkey: '_removeAnimationClasses',\n\t\t\tvalue: function _removeAnimationClasses(elem) {\n\t\t\t\tvar prefix = this.options.classPrefix;\n\t\t\t\telem.classList.remove(prefix + 'to-right', prefix + 'to-left', prefix + 'from-right', prefix + 'from-left');\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'play',\n\t\t\tvalue: function play() {\n\t\t\t\tif (this.playing || typeof this.options.slideDuration !== 'number' || this.options.slideDuration <= 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.playing = true;\n\t\t\t\tthis.timer = setInterval(this.next.bind(this), this.options.slideDuration * 1000);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'stop',\n\t\t\tvalue: function stop() {\n\t\t\t\tthis.playing = false;\n\t\t\t\tclearInterval(this.timer);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'next',\n\t\t\tvalue: function next() {\n\t\t\t\tvar nextIndex = this.currentIndex + 1;\n\t\t\t\tif (nextIndex > this.maxIndex) {\n\t\t\t\t\tnextIndex = 0;\n\t\t\t\t}\n\t\t\t\treturn this.goToSlide(nextIndex);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'previous',\n\t\t\tvalue: function previous() {\n\t\t\t\tvar nextIndex = this.currentIndex - 1;\n\t\t\t\tif (nextIndex < 0) {\n\t\t\t\t\tnextIndex = this.maxIndex;\n\t\t\t\t}\n\t\t\t\treturn this.goToSlide(nextIndex);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'goToSlide',\n\t\t\tvalue: function goToSlide(index) {\n\t\t\t\tvar prefix, children, oldPrevious, previous, current, oldIndex;\n\t\n\t\t\t\tif (index < 0 || index > this.maxIndex) {\n\t\t\t\t\tthrow new TypeError('Slide index out of bounds');\n\t\t\t\t}\n\t\n\t\t\t\tif (index === this.currentIndex) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\tprefix = this.options.classPrefix;\n\t\t\t\tchildren = this.element.children;\n\t\n\t\t\t\toldPrevious = this.previousSlide;\n\t\t\t\tprevious = this.currentSlide;\n\t\n\t\t\t\toldIndex = this.currentIndex;\n\t\t\t\tthis.currentIndex = index;\n\t\t\t\tcurrent = children[index];\n\t\n\t\t\t\tthis._removeAnimationClasses(oldPrevious);\n\t\t\t\toldPrevious.classList.remove(prefix + 'previous');\n\t\t\t\toldPrevious.classList.add(prefix + 'hidden');\n\t\n\t\t\t\tthis._removeAnimationClasses(previous);\n\t\t\t\tprevious.classList.remove(prefix + 'current');\n\t\t\t\tprevious.classList.add(prefix + 'previous');\n\t\t\t\tif (this.options.continuousLoop && this.currentIndex === 0 && oldIndex === this.maxIndex) {\n\t\t\t\t\tprevious.classList.add(prefix + 'to-left');\n\t\t\t\t} else if (this.options.continuousLoop && this.currentIndex === this.maxIndex && oldIndex === 0) {\n\t\t\t\t\tprevious.classList.add(prefix + 'to-right');\n\t\t\t\t} else if (this.currentIndex > oldIndex) {\n\t\t\t\t\tprevious.classList.add(prefix + 'to-left');\n\t\t\t\t} else {\n\t\t\t\t\tprevious.classList.add(prefix + 'to-right');\n\t\t\t\t}\n\t\n\t\t\t\tcurrent.classList.remove(prefix + 'hidden');\n\t\t\t\tcurrent.classList.add(prefix + 'current');\n\t\t\t\tif (this.options.continuousLoop && this.currentIndex === 0 && oldIndex === this.maxIndex) {\n\t\t\t\t\tcurrent.classList.add(prefix + 'from-right');\n\t\t\t\t} else if (this.options.continuousLoop && this.currentIndex === this.maxIndex && oldIndex === 0) {\n\t\t\t\t\tcurrent.classList.add(prefix + 'from-left');\n\t\t\t\t} else if (this.currentIndex > oldIndex) {\n\t\t\t\t\tcurrent.classList.add(prefix + 'from-right');\n\t\t\t\t} else {\n\t\t\t\t\tcurrent.classList.add(prefix + 'from-left');\n\t\t\t\t}\n\t\n\t\t\t\tthis.previousSlide = previous;\n\t\t\t\tthis.currentSlide = current;\n\t\n\t\t\t\tthis.emit('change');\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'destroy',\n\t\t\tvalue: function destroy(removeClasses) {\n\t\t\t\tvar prefix;\n\t\t\t\tif (touchEnabled && this.options.touch) {\n\t\t\t\t\tthis.hammer.destroy();\n\t\t\t\t}\n\t\t\t\tif (removeClasses) {\n\t\t\t\t\tthis._removeClasses();\n\t\t\t\t}\n\t\t\t\tthis.stop();\n\t\t\t\tthis.removeAllListeners();\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn Auru;\n\t})(EventEmitter);\n\t\n\texports.default = Auru;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 1 */,\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict'\n\t\n\t//\n\t// We store our EE objects in a plain object whose properties are event names.\n\t// If `Object.create(null)` is not supported we prefix the event names with a\n\t// `~` to make sure that the built-in object properties are not overridden or\n\t// used as an attack vector.\n\t// We also assume that `Object.create(null)` is available when the event name\n\t// is an ES6 Symbol.\n\t//\n\t;\n\tvar prefix = typeof Object.create !== 'function' ? '~' : false;\n\t\n\t/**\n\t * Representation of a single EventEmitter function.\n\t *\n\t * @param {Function} fn Event handler to be called.\n\t * @param {Mixed} context Context for function execution.\n\t * @param {Boolean} once Only emit once\n\t * @api private\n\t */\n\tfunction EE(fn, context, once) {\n\t  this.fn = fn;\n\t  this.context = context;\n\t  this.once = once || false;\n\t}\n\t\n\t/**\n\t * Minimal EventEmitter interface that is molded against the Node.js\n\t * EventEmitter interface.\n\t *\n\t * @constructor\n\t * @api public\n\t */\n\tfunction EventEmitter() {} /* Nothing to set */\n\t\n\t/**\n\t * Holds the assigned EventEmitters by name.\n\t *\n\t * @type {Object}\n\t * @private\n\t */\n\tEventEmitter.prototype._events = undefined;\n\t\n\t/**\n\t * Return a list of assigned event listeners.\n\t *\n\t * @param {String} event The events that should be listed.\n\t * @param {Boolean} exists We only need to know if there are listeners.\n\t * @returns {Array|Boolean}\n\t * @api public\n\t */\n\tEventEmitter.prototype.listeners = function listeners(event, exists) {\n\t  var evt = prefix ? prefix + event : event,\n\t      available = this._events && this._events[evt];\n\t\n\t  if (exists) return !!available;\n\t  if (!available) return [];\n\t  if (available.fn) return [available.fn];\n\t\n\t  for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {\n\t    ee[i] = available[i].fn;\n\t  }\n\t\n\t  return ee;\n\t};\n\t\n\t/**\n\t * Emit an event to all registered event listeners.\n\t *\n\t * @param {String} event The name of the event.\n\t * @returns {Boolean} Indication if we've emitted an event.\n\t * @api public\n\t */\n\tEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n\t  var evt = prefix ? prefix + event : event;\n\t\n\t  if (!this._events || !this._events[evt]) return false;\n\t\n\t  var listeners = this._events[evt],\n\t      len = arguments.length,\n\t      args,\n\t      i;\n\t\n\t  if ('function' === typeof listeners.fn) {\n\t    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\t\n\t    switch (len) {\n\t      case 1:\n\t        return listeners.fn.call(listeners.context), true;\n\t      case 2:\n\t        return listeners.fn.call(listeners.context, a1), true;\n\t      case 3:\n\t        return listeners.fn.call(listeners.context, a1, a2), true;\n\t      case 4:\n\t        return listeners.fn.call(listeners.context, a1, a2, a3), true;\n\t      case 5:\n\t        return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n\t      case 6:\n\t        return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n\t    }\n\t\n\t    for (i = 1, args = new Array(len - 1); i < len; i++) {\n\t      args[i - 1] = arguments[i];\n\t    }\n\t\n\t    listeners.fn.apply(listeners.context, args);\n\t  } else {\n\t    var length = listeners.length,\n\t        j;\n\t\n\t    for (i = 0; i < length; i++) {\n\t      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\t\n\t      switch (len) {\n\t        case 1:\n\t          listeners[i].fn.call(listeners[i].context);break;\n\t        case 2:\n\t          listeners[i].fn.call(listeners[i].context, a1);break;\n\t        case 3:\n\t          listeners[i].fn.call(listeners[i].context, a1, a2);break;\n\t        default:\n\t          if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {\n\t            args[j - 1] = arguments[j];\n\t          }\n\t\n\t          listeners[i].fn.apply(listeners[i].context, args);\n\t      }\n\t    }\n\t  }\n\t\n\t  return true;\n\t};\n\t\n\t/**\n\t * Register a new EventListener for the given event.\n\t *\n\t * @param {String} event Name of the event.\n\t * @param {Functon} fn Callback function.\n\t * @param {Mixed} context The context of the function.\n\t * @api public\n\t */\n\tEventEmitter.prototype.on = function on(event, fn, context) {\n\t  var listener = new EE(fn, context || this),\n\t      evt = prefix ? prefix + event : event;\n\t\n\t  if (!this._events) this._events = prefix ? {} : Object.create(null);\n\t  if (!this._events[evt]) this._events[evt] = listener;else {\n\t    if (!this._events[evt].fn) this._events[evt].push(listener);else this._events[evt] = [this._events[evt], listener];\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Add an EventListener that's only called once.\n\t *\n\t * @param {String} event Name of the event.\n\t * @param {Function} fn Callback function.\n\t * @param {Mixed} context The context of the function.\n\t * @api public\n\t */\n\tEventEmitter.prototype.once = function once(event, fn, context) {\n\t  var listener = new EE(fn, context || this, true),\n\t      evt = prefix ? prefix + event : event;\n\t\n\t  if (!this._events) this._events = prefix ? {} : Object.create(null);\n\t  if (!this._events[evt]) this._events[evt] = listener;else {\n\t    if (!this._events[evt].fn) this._events[evt].push(listener);else this._events[evt] = [this._events[evt], listener];\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Remove event listeners.\n\t *\n\t * @param {String} event The event we want to remove.\n\t * @param {Function} fn The listener that we need to find.\n\t * @param {Mixed} context Only remove listeners matching this context.\n\t * @param {Boolean} once Only remove once listeners.\n\t * @api public\n\t */\n\tEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n\t  var evt = prefix ? prefix + event : event;\n\t\n\t  if (!this._events || !this._events[evt]) return this;\n\t\n\t  var listeners = this._events[evt],\n\t      events = [];\n\t\n\t  if (fn) {\n\t    if (listeners.fn) {\n\t      if (listeners.fn !== fn || once && !listeners.once || context && listeners.context !== context) {\n\t        events.push(listeners);\n\t      }\n\t    } else {\n\t      for (var i = 0, length = listeners.length; i < length; i++) {\n\t        if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {\n\t          events.push(listeners[i]);\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  //\n\t  // Reset the array, or remove it completely if we have no more listeners.\n\t  //\n\t  if (events.length) {\n\t    this._events[evt] = events.length === 1 ? events[0] : events;\n\t  } else {\n\t    delete this._events[evt];\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Remove all listeners or only the listeners for the specified event.\n\t *\n\t * @param {String} event The event want to remove all listeners for.\n\t * @api public\n\t */\n\tEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n\t  if (!this._events) return this;\n\t\n\t  if (event) delete this._events[prefix ? prefix + event : event];else this._events = prefix ? {} : Object.create(null);\n\t\n\t  return this;\n\t};\n\t\n\t//\n\t// Alias methods names because people roll like that.\n\t//\n\tEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\tEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\t\n\t//\n\t// This function doesn't apply anymore.\n\t//\n\tEventEmitter.prototype.setMaxListeners = function setMaxListeners() {\n\t  return this;\n\t};\n\t\n\t//\n\t// Expose the prefix.\n\t//\n\tEventEmitter.prefixed = prefix;\n\t\n\t//\n\t// Expose the module.\n\t//\n\tif (true) {\n\t  module.exports = EventEmitter;\n\t}\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;'use strict';\n\t\n\tfunction _typeof(obj) { return obj && typeof Symbol !== \"undefined\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; }\n\t\n\t/*! Hammer.JS - v2.0.4 - 2014-09-28\r\n\t * http://hammerjs.github.io/\r\n\t *\r\n\t * Copyright (c) 2014 Jorik Tangelder;\r\n\t * Licensed under the MIT license */\n\t(function (window, document, exportName, undefined) {\n\t    'use strict';\n\t\n\t    var VENDOR_PREFIXES = ['', 'webkit', 'moz', 'MS', 'ms', 'o'];\n\t    var TEST_ELEMENT = document.createElement('div');\n\t\n\t    var TYPE_FUNCTION = 'function';\n\t\n\t    var round = Math.round;\n\t    var abs = Math.abs;\n\t    var now = Date.now;\n\t\n\t    /**\r\n\t     * set a timeout with a given scope\r\n\t     * @param {Function} fn\r\n\t     * @param {Number} timeout\r\n\t     * @param {Object} context\r\n\t     * @returns {number}\r\n\t     */\n\t    function setTimeoutContext(fn, timeout, context) {\n\t        return setTimeout(bindFn(fn, context), timeout);\n\t    }\n\t\n\t    /**\r\n\t     * if the argument is an array, we want to execute the fn on each entry\r\n\t     * if it aint an array we don't want to do a thing.\r\n\t     * this is used by all the methods that accept a single and array argument.\r\n\t     * @param {*|Array} arg\r\n\t     * @param {String} fn\r\n\t     * @param {Object} [context]\r\n\t     * @returns {Boolean}\r\n\t     */\n\t    function invokeArrayArg(arg, fn, context) {\n\t        if (Array.isArray(arg)) {\n\t            each(arg, context[fn], context);\n\t            return true;\n\t        }\n\t        return false;\n\t    }\n\t\n\t    /**\r\n\t     * walk objects and arrays\r\n\t     * @param {Object} obj\r\n\t     * @param {Function} iterator\r\n\t     * @param {Object} context\r\n\t     */\n\t    function each(obj, iterator, context) {\n\t        var i;\n\t\n\t        if (!obj) {\n\t            return;\n\t        }\n\t\n\t        if (obj.forEach) {\n\t            obj.forEach(iterator, context);\n\t        } else if (obj.length !== undefined) {\n\t            i = 0;\n\t            while (i < obj.length) {\n\t                iterator.call(context, obj[i], i, obj);\n\t                i++;\n\t            }\n\t        } else {\n\t            for (i in obj) {\n\t                obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\r\n\t     * extend object.\r\n\t     * means that properties in dest will be overwritten by the ones in src.\r\n\t     * @param {Object} dest\r\n\t     * @param {Object} src\r\n\t     * @param {Boolean} [merge]\r\n\t     * @returns {Object} dest\r\n\t     */\n\t    function extend(dest, src, merge) {\n\t        var keys = Object.keys(src);\n\t        var i = 0;\n\t        while (i < keys.length) {\n\t            if (!merge || merge && dest[keys[i]] === undefined) {\n\t                dest[keys[i]] = src[keys[i]];\n\t            }\n\t            i++;\n\t        }\n\t        return dest;\n\t    }\n\t\n\t    /**\r\n\t     * merge the values from src in the dest.\r\n\t     * means that properties that exist in dest will not be overwritten by src\r\n\t     * @param {Object} dest\r\n\t     * @param {Object} src\r\n\t     * @returns {Object} dest\r\n\t     */\n\t    function merge(dest, src) {\n\t        return extend(dest, src, true);\n\t    }\n\t\n\t    /**\r\n\t     * simple class inheritance\r\n\t     * @param {Function} child\r\n\t     * @param {Function} base\r\n\t     * @param {Object} [properties]\r\n\t     */\n\t    function inherit(child, base, properties) {\n\t        var baseP = base.prototype,\n\t            childP;\n\t\n\t        childP = child.prototype = Object.create(baseP);\n\t        childP.constructor = child;\n\t        childP._super = baseP;\n\t\n\t        if (properties) {\n\t            extend(childP, properties);\n\t        }\n\t    }\n\t\n\t    /**\r\n\t     * simple function bind\r\n\t     * @param {Function} fn\r\n\t     * @param {Object} context\r\n\t     * @returns {Function}\r\n\t     */\n\t    function bindFn(fn, context) {\n\t        return function boundFn() {\n\t            return fn.apply(context, arguments);\n\t        };\n\t    }\n\t\n\t    /**\r\n\t     * let a boolean value also be a function that must return a boolean\r\n\t     * this first item in args will be used as the context\r\n\t     * @param {Boolean|Function} val\r\n\t     * @param {Array} [args]\r\n\t     * @returns {Boolean}\r\n\t     */\n\t    function boolOrFn(val, args) {\n\t        if ((typeof val === 'undefined' ? 'undefined' : _typeof(val)) == TYPE_FUNCTION) {\n\t            return val.apply(args ? args[0] || undefined : undefined, args);\n\t        }\n\t        return val;\n\t    }\n\t\n\t    /**\r\n\t     * use the val2 when val1 is undefined\r\n\t     * @param {*} val1\r\n\t     * @param {*} val2\r\n\t     * @returns {*}\r\n\t     */\n\t    function ifUndefined(val1, val2) {\n\t        return val1 === undefined ? val2 : val1;\n\t    }\n\t\n\t    /**\r\n\t     * addEventListener with multiple events at once\r\n\t     * @param {EventTarget} target\r\n\t     * @param {String} types\r\n\t     * @param {Function} handler\r\n\t     */\n\t    function addEventListeners(target, types, handler) {\n\t        each(splitStr(types), function (type) {\n\t            target.addEventListener(type, handler, false);\n\t        });\n\t    }\n\t\n\t    /**\r\n\t     * removeEventListener with multiple events at once\r\n\t     * @param {EventTarget} target\r\n\t     * @param {String} types\r\n\t     * @param {Function} handler\r\n\t     */\n\t    function removeEventListeners(target, types, handler) {\n\t        each(splitStr(types), function (type) {\n\t            target.removeEventListener(type, handler, false);\n\t        });\n\t    }\n\t\n\t    /**\r\n\t     * find if a node is in the given parent\r\n\t     * @method hasParent\r\n\t     * @param {HTMLElement} node\r\n\t     * @param {HTMLElement} parent\r\n\t     * @return {Boolean} found\r\n\t     */\n\t    function hasParent(node, parent) {\n\t        while (node) {\n\t            if (node == parent) {\n\t                return true;\n\t            }\n\t            node = node.parentNode;\n\t        }\n\t        return false;\n\t    }\n\t\n\t    /**\r\n\t     * small indexOf wrapper\r\n\t     * @param {String} str\r\n\t     * @param {String} find\r\n\t     * @returns {Boolean} found\r\n\t     */\n\t    function inStr(str, find) {\n\t        return str.indexOf(find) > -1;\n\t    }\n\t\n\t    /**\r\n\t     * split string on whitespace\r\n\t     * @param {String} str\r\n\t     * @returns {Array} words\r\n\t     */\n\t    function splitStr(str) {\n\t        return str.trim().split(/\\s+/g);\n\t    }\n\t\n\t    /**\r\n\t     * find if a array contains the object using indexOf or a simple polyFill\r\n\t     * @param {Array} src\r\n\t     * @param {String} find\r\n\t     * @param {String} [findByKey]\r\n\t     * @return {Boolean|Number} false when not found, or the index\r\n\t     */\n\t    function inArray(src, find, findByKey) {\n\t        if (src.indexOf && !findByKey) {\n\t            return src.indexOf(find);\n\t        } else {\n\t            var i = 0;\n\t            while (i < src.length) {\n\t                if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {\n\t                    return i;\n\t                }\n\t                i++;\n\t            }\n\t            return -1;\n\t        }\n\t    }\n\t\n\t    /**\r\n\t     * convert array-like objects to real arrays\r\n\t     * @param {Object} obj\r\n\t     * @returns {Array}\r\n\t     */\n\t    function toArray(obj) {\n\t        return Array.prototype.slice.call(obj, 0);\n\t    }\n\t\n\t    /**\r\n\t     * unique array with objects based on a key (like 'id') or just by the array's value\r\n\t     * @param {Array} src [{id:1},{id:2},{id:1}]\r\n\t     * @param {String} [key]\r\n\t     * @param {Boolean} [sort=False]\r\n\t     * @returns {Array} [{id:1},{id:2}]\r\n\t     */\n\t    function uniqueArray(src, key, sort) {\n\t        var results = [];\n\t        var values = [];\n\t        var i = 0;\n\t\n\t        while (i < src.length) {\n\t            var val = key ? src[i][key] : src[i];\n\t            if (inArray(values, val) < 0) {\n\t                results.push(src[i]);\n\t            }\n\t            values[i] = val;\n\t            i++;\n\t        }\n\t\n\t        if (sort) {\n\t            if (!key) {\n\t                results = results.sort();\n\t            } else {\n\t                results = results.sort(function sortUniqueArray(a, b) {\n\t                    return a[key] > b[key];\n\t                });\n\t            }\n\t        }\n\t\n\t        return results;\n\t    }\n\t\n\t    /**\r\n\t     * get the prefixed property\r\n\t     * @param {Object} obj\r\n\t     * @param {String} property\r\n\t     * @returns {String|Undefined} prefixed\r\n\t     */\n\t    function prefixed(obj, property) {\n\t        var prefix, prop;\n\t        var camelProp = property[0].toUpperCase() + property.slice(1);\n\t\n\t        var i = 0;\n\t        while (i < VENDOR_PREFIXES.length) {\n\t            prefix = VENDOR_PREFIXES[i];\n\t            prop = prefix ? prefix + camelProp : property;\n\t\n\t            if (prop in obj) {\n\t                return prop;\n\t            }\n\t            i++;\n\t        }\n\t        return undefined;\n\t    }\n\t\n\t    /**\r\n\t     * get a unique id\r\n\t     * @returns {number} uniqueId\r\n\t     */\n\t    var _uniqueId = 1;\n\t    function uniqueId() {\n\t        return _uniqueId++;\n\t    }\n\t\n\t    /**\r\n\t     * get the window object of an element\r\n\t     * @param {HTMLElement} element\r\n\t     * @returns {DocumentView|Window}\r\n\t     */\n\t    function getWindowForElement(element) {\n\t        var doc = element.ownerDocument;\n\t        return doc.defaultView || doc.parentWindow;\n\t    }\n\t\n\t    var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\n\t\n\t    var SUPPORT_TOUCH = 'ontouchstart' in window;\n\t    var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\n\t    var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\n\t\n\t    var INPUT_TYPE_TOUCH = 'touch';\n\t    var INPUT_TYPE_PEN = 'pen';\n\t    var INPUT_TYPE_MOUSE = 'mouse';\n\t    var INPUT_TYPE_KINECT = 'kinect';\n\t\n\t    var COMPUTE_INTERVAL = 25;\n\t\n\t    var INPUT_START = 1;\n\t    var INPUT_MOVE = 2;\n\t    var INPUT_END = 4;\n\t    var INPUT_CANCEL = 8;\n\t\n\t    var DIRECTION_NONE = 1;\n\t    var DIRECTION_LEFT = 2;\n\t    var DIRECTION_RIGHT = 4;\n\t    var DIRECTION_UP = 8;\n\t    var DIRECTION_DOWN = 16;\n\t\n\t    var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\n\t    var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\n\t    var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\n\t\n\t    var PROPS_XY = ['x', 'y'];\n\t    var PROPS_CLIENT_XY = ['clientX', 'clientY'];\n\t\n\t    /**\r\n\t     * create new input type manager\r\n\t     * @param {Manager} manager\r\n\t     * @param {Function} callback\r\n\t     * @returns {Input}\r\n\t     * @constructor\r\n\t     */\n\t    function Input(manager, callback) {\n\t        var self = this;\n\t        this.manager = manager;\n\t        this.callback = callback;\n\t        this.element = manager.element;\n\t        this.target = manager.options.inputTarget;\n\t\n\t        // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n\t        // so when disabled the input events are completely bypassed.\n\t        this.domHandler = function (ev) {\n\t            if (boolOrFn(manager.options.enable, [manager])) {\n\t                self.handler(ev);\n\t            }\n\t        };\n\t\n\t        this.init();\n\t    }\n\t\n\t    Input.prototype = {\n\t        /**\r\n\t         * should handle the inputEvent data and trigger the callback\r\n\t         * @virtual\r\n\t         */\n\t        handler: function handler() {},\n\t\n\t        /**\r\n\t         * bind the events\r\n\t         */\n\t        init: function init() {\n\t            this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n\t            this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n\t            this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n\t        },\n\t\n\t        /**\r\n\t         * unbind the events\r\n\t         */\n\t        destroy: function destroy() {\n\t            this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n\t            this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n\t            this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n\t        }\n\t    };\n\t\n\t    /**\r\n\t     * create new input type manager\r\n\t     * called by the Manager constructor\r\n\t     * @param {Hammer} manager\r\n\t     * @returns {Input}\r\n\t     */\n\t    function createInputInstance(manager) {\n\t        var Type;\n\t        var inputClass = manager.options.inputClass;\n\t\n\t        if (inputClass) {\n\t            Type = inputClass;\n\t        } else if (SUPPORT_POINTER_EVENTS) {\n\t            Type = PointerEventInput;\n\t        } else if (SUPPORT_ONLY_TOUCH) {\n\t            Type = TouchInput;\n\t        } else if (!SUPPORT_TOUCH) {\n\t            Type = MouseInput;\n\t        } else {\n\t            Type = TouchMouseInput;\n\t        }\n\t        return new Type(manager, inputHandler);\n\t    }\n\t\n\t    /**\r\n\t     * handle input events\r\n\t     * @param {Manager} manager\r\n\t     * @param {String} eventType\r\n\t     * @param {Object} input\r\n\t     */\n\t    function inputHandler(manager, eventType, input) {\n\t        var pointersLen = input.pointers.length;\n\t        var changedPointersLen = input.changedPointers.length;\n\t        var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;\n\t        var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;\n\t\n\t        input.isFirst = !!isFirst;\n\t        input.isFinal = !!isFinal;\n\t\n\t        if (isFirst) {\n\t            manager.session = {};\n\t        }\n\t\n\t        // source event is the normalized value of the domEvents\n\t        // like 'touchstart, mouseup, pointerdown'\n\t        input.eventType = eventType;\n\t\n\t        // compute scale, rotation etc\n\t        computeInputData(manager, input);\n\t\n\t        // emit secret event\n\t        manager.emit('hammer.input', input);\n\t\n\t        manager.recognize(input);\n\t        manager.session.prevInput = input;\n\t    }\n\t\n\t    /**\r\n\t     * extend the data with some usable properties like scale, rotate, velocity etc\r\n\t     * @param {Object} manager\r\n\t     * @param {Object} input\r\n\t     */\n\t    function computeInputData(manager, input) {\n\t        var session = manager.session;\n\t        var pointers = input.pointers;\n\t        var pointersLength = pointers.length;\n\t\n\t        // store the first input to calculate the distance and direction\n\t        if (!session.firstInput) {\n\t            session.firstInput = simpleCloneInputData(input);\n\t        }\n\t\n\t        // to compute scale and rotation we need to store the multiple touches\n\t        if (pointersLength > 1 && !session.firstMultiple) {\n\t            session.firstMultiple = simpleCloneInputData(input);\n\t        } else if (pointersLength === 1) {\n\t            session.firstMultiple = false;\n\t        }\n\t\n\t        var firstInput = session.firstInput;\n\t        var firstMultiple = session.firstMultiple;\n\t        var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n\t\n\t        var center = input.center = getCenter(pointers);\n\t        input.timeStamp = now();\n\t        input.deltaTime = input.timeStamp - firstInput.timeStamp;\n\t\n\t        input.angle = getAngle(offsetCenter, center);\n\t        input.distance = getDistance(offsetCenter, center);\n\t\n\t        computeDeltaXY(session, input);\n\t        input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n\t\n\t        input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n\t        input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n\t\n\t        computeIntervalInputData(session, input);\n\t\n\t        // find the correct target\n\t        var target = manager.element;\n\t        if (hasParent(input.srcEvent.target, target)) {\n\t            target = input.srcEvent.target;\n\t        }\n\t        input.target = target;\n\t    }\n\t\n\t    function computeDeltaXY(session, input) {\n\t        var center = input.center;\n\t        var offset = session.offsetDelta || {};\n\t        var prevDelta = session.prevDelta || {};\n\t        var prevInput = session.prevInput || {};\n\t\n\t        if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n\t            prevDelta = session.prevDelta = {\n\t                x: prevInput.deltaX || 0,\n\t                y: prevInput.deltaY || 0\n\t            };\n\t\n\t            offset = session.offsetDelta = {\n\t                x: center.x,\n\t                y: center.y\n\t            };\n\t        }\n\t\n\t        input.deltaX = prevDelta.x + (center.x - offset.x);\n\t        input.deltaY = prevDelta.y + (center.y - offset.y);\n\t    }\n\t\n\t    /**\r\n\t     * velocity is calculated every x ms\r\n\t     * @param {Object} session\r\n\t     * @param {Object} input\r\n\t     */\n\t    function computeIntervalInputData(session, input) {\n\t        var last = session.lastInterval || input,\n\t            deltaTime = input.timeStamp - last.timeStamp,\n\t            velocity,\n\t            velocityX,\n\t            velocityY,\n\t            direction;\n\t\n\t        if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n\t            var deltaX = last.deltaX - input.deltaX;\n\t            var deltaY = last.deltaY - input.deltaY;\n\t\n\t            var v = getVelocity(deltaTime, deltaX, deltaY);\n\t            velocityX = v.x;\n\t            velocityY = v.y;\n\t            velocity = abs(v.x) > abs(v.y) ? v.x : v.y;\n\t            direction = getDirection(deltaX, deltaY);\n\t\n\t            session.lastInterval = input;\n\t        } else {\n\t            // use latest velocity info if it doesn't overtake a minimum period\n\t            velocity = last.velocity;\n\t            velocityX = last.velocityX;\n\t            velocityY = last.velocityY;\n\t            direction = last.direction;\n\t        }\n\t\n\t        input.velocity = velocity;\n\t        input.velocityX = velocityX;\n\t        input.velocityY = velocityY;\n\t        input.direction = direction;\n\t    }\n\t\n\t    /**\r\n\t     * create a simple clone from the input used for storage of firstInput and firstMultiple\r\n\t     * @param {Object} input\r\n\t     * @returns {Object} clonedInputData\r\n\t     */\n\t    function simpleCloneInputData(input) {\n\t        // make a simple copy of the pointers because we will get a reference if we don't\n\t        // we only need clientXY for the calculations\n\t        var pointers = [];\n\t        var i = 0;\n\t        while (i < input.pointers.length) {\n\t            pointers[i] = {\n\t                clientX: round(input.pointers[i].clientX),\n\t                clientY: round(input.pointers[i].clientY)\n\t            };\n\t            i++;\n\t        }\n\t\n\t        return {\n\t            timeStamp: now(),\n\t            pointers: pointers,\n\t            center: getCenter(pointers),\n\t            deltaX: input.deltaX,\n\t            deltaY: input.deltaY\n\t        };\n\t    }\n\t\n\t    /**\r\n\t     * get the center of all the pointers\r\n\t     * @param {Array} pointers\r\n\t     * @return {Object} center contains `x` and `y` properties\r\n\t     */\n\t    function getCenter(pointers) {\n\t        var pointersLength = pointers.length;\n\t\n\t        // no need to loop when only one touch\n\t        if (pointersLength === 1) {\n\t            return {\n\t                x: round(pointers[0].clientX),\n\t                y: round(pointers[0].clientY)\n\t            };\n\t        }\n\t\n\t        var x = 0,\n\t            y = 0,\n\t            i = 0;\n\t        while (i < pointersLength) {\n\t            x += pointers[i].clientX;\n\t            y += pointers[i].clientY;\n\t            i++;\n\t        }\n\t\n\t        return {\n\t            x: round(x / pointersLength),\n\t            y: round(y / pointersLength)\n\t        };\n\t    }\n\t\n\t    /**\r\n\t     * calculate the velocity between two points. unit is in px per ms.\r\n\t     * @param {Number} deltaTime\r\n\t     * @param {Number} x\r\n\t     * @param {Number} y\r\n\t     * @return {Object} velocity `x` and `y`\r\n\t     */\n\t    function getVelocity(deltaTime, x, y) {\n\t        return {\n\t            x: x / deltaTime || 0,\n\t            y: y / deltaTime || 0\n\t        };\n\t    }\n\t\n\t    /**\r\n\t     * get the direction between two points\r\n\t     * @param {Number} x\r\n\t     * @param {Number} y\r\n\t     * @return {Number} direction\r\n\t     */\n\t    function getDirection(x, y) {\n\t        if (x === y) {\n\t            return DIRECTION_NONE;\n\t        }\n\t\n\t        if (abs(x) >= abs(y)) {\n\t            return x > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n\t        }\n\t        return y > 0 ? DIRECTION_UP : DIRECTION_DOWN;\n\t    }\n\t\n\t    /**\r\n\t     * calculate the absolute distance between two points\r\n\t     * @param {Object} p1 {x, y}\r\n\t     * @param {Object} p2 {x, y}\r\n\t     * @param {Array} [props] containing x and y keys\r\n\t     * @return {Number} distance\r\n\t     */\n\t    function getDistance(p1, p2, props) {\n\t        if (!props) {\n\t            props = PROPS_XY;\n\t        }\n\t        var x = p2[props[0]] - p1[props[0]],\n\t            y = p2[props[1]] - p1[props[1]];\n\t\n\t        return Math.sqrt(x * x + y * y);\n\t    }\n\t\n\t    /**\r\n\t     * calculate the angle between two coordinates\r\n\t     * @param {Object} p1\r\n\t     * @param {Object} p2\r\n\t     * @param {Array} [props] containing x and y keys\r\n\t     * @return {Number} angle\r\n\t     */\n\t    function getAngle(p1, p2, props) {\n\t        if (!props) {\n\t            props = PROPS_XY;\n\t        }\n\t        var x = p2[props[0]] - p1[props[0]],\n\t            y = p2[props[1]] - p1[props[1]];\n\t        return Math.atan2(y, x) * 180 / Math.PI;\n\t    }\n\t\n\t    /**\r\n\t     * calculate the rotation degrees between two pointersets\r\n\t     * @param {Array} start array of pointers\r\n\t     * @param {Array} end array of pointers\r\n\t     * @return {Number} rotation\r\n\t     */\n\t    function getRotation(start, end) {\n\t        return getAngle(end[1], end[0], PROPS_CLIENT_XY) - getAngle(start[1], start[0], PROPS_CLIENT_XY);\n\t    }\n\t\n\t    /**\r\n\t     * calculate the scale factor between two pointersets\r\n\t     * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\r\n\t     * @param {Array} start array of pointers\r\n\t     * @param {Array} end array of pointers\r\n\t     * @return {Number} scale\r\n\t     */\n\t    function getScale(start, end) {\n\t        return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n\t    }\n\t\n\t    var MOUSE_INPUT_MAP = {\n\t        mousedown: INPUT_START,\n\t        mousemove: INPUT_MOVE,\n\t        mouseup: INPUT_END\n\t    };\n\t\n\t    var MOUSE_ELEMENT_EVENTS = 'mousedown';\n\t    var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n\t\n\t    /**\r\n\t     * Mouse events input\r\n\t     * @constructor\r\n\t     * @extends Input\r\n\t     */\n\t    function MouseInput() {\n\t        this.evEl = MOUSE_ELEMENT_EVENTS;\n\t        this.evWin = MOUSE_WINDOW_EVENTS;\n\t\n\t        this.allow = true; // used by Input.TouchMouse to disable mouse events\n\t        this.pressed = false; // mousedown state\n\t\n\t        Input.apply(this, arguments);\n\t    }\n\t\n\t    inherit(MouseInput, Input, {\n\t        /**\r\n\t         * handle mouse events\r\n\t         * @param {Object} ev\r\n\t         */\n\t        handler: function MEhandler(ev) {\n\t            var eventType = MOUSE_INPUT_MAP[ev.type];\n\t\n\t            // on start we want to have the left mouse button down\n\t            if (eventType & INPUT_START && ev.button === 0) {\n\t                this.pressed = true;\n\t            }\n\t\n\t            if (eventType & INPUT_MOVE && ev.which !== 1) {\n\t                eventType = INPUT_END;\n\t            }\n\t\n\t            // mouse must be down, and mouse events are allowed (see the TouchMouse input)\n\t            if (!this.pressed || !this.allow) {\n\t                return;\n\t            }\n\t\n\t            if (eventType & INPUT_END) {\n\t                this.pressed = false;\n\t            }\n\t\n\t            this.callback(this.manager, eventType, {\n\t                pointers: [ev],\n\t                changedPointers: [ev],\n\t                pointerType: INPUT_TYPE_MOUSE,\n\t                srcEvent: ev\n\t            });\n\t        }\n\t    });\n\t\n\t    var POINTER_INPUT_MAP = {\n\t        pointerdown: INPUT_START,\n\t        pointermove: INPUT_MOVE,\n\t        pointerup: INPUT_END,\n\t        pointercancel: INPUT_CANCEL,\n\t        pointerout: INPUT_CANCEL\n\t    };\n\t\n\t    // in IE10 the pointer types is defined as an enum\n\t    var IE10_POINTER_TYPE_ENUM = {\n\t        2: INPUT_TYPE_TOUCH,\n\t        3: INPUT_TYPE_PEN,\n\t        4: INPUT_TYPE_MOUSE,\n\t        5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n\t    };\n\t\n\t    var POINTER_ELEMENT_EVENTS = 'pointerdown';\n\t    var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';\n\t\n\t    // IE10 has prefixed support, and case-sensitive\n\t    if (window.MSPointerEvent) {\n\t        POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n\t        POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n\t    }\n\t\n\t    /**\r\n\t     * Pointer events input\r\n\t     * @constructor\r\n\t     * @extends Input\r\n\t     */\n\t    function PointerEventInput() {\n\t        this.evEl = POINTER_ELEMENT_EVENTS;\n\t        this.evWin = POINTER_WINDOW_EVENTS;\n\t\n\t        Input.apply(this, arguments);\n\t\n\t        this.store = this.manager.session.pointerEvents = [];\n\t    }\n\t\n\t    inherit(PointerEventInput, Input, {\n\t        /**\r\n\t         * handle mouse events\r\n\t         * @param {Object} ev\r\n\t         */\n\t        handler: function PEhandler(ev) {\n\t            var store = this.store;\n\t            var removePointer = false;\n\t\n\t            var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n\t            var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n\t            var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n\t\n\t            var isTouch = pointerType == INPUT_TYPE_TOUCH;\n\t\n\t            // get index of the event in the store\n\t            var storeIndex = inArray(store, ev.pointerId, 'pointerId');\n\t\n\t            // start and mouse must be down\n\t            if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n\t                if (storeIndex < 0) {\n\t                    store.push(ev);\n\t                    storeIndex = store.length - 1;\n\t                }\n\t            } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n\t                removePointer = true;\n\t            }\n\t\n\t            // it not found, so the pointer hasn't been down (so it's probably a hover)\n\t            if (storeIndex < 0) {\n\t                return;\n\t            }\n\t\n\t            // update the event in the store\n\t            store[storeIndex] = ev;\n\t\n\t            this.callback(this.manager, eventType, {\n\t                pointers: store,\n\t                changedPointers: [ev],\n\t                pointerType: pointerType,\n\t                srcEvent: ev\n\t            });\n\t\n\t            if (removePointer) {\n\t                // remove from the store\n\t                store.splice(storeIndex, 1);\n\t            }\n\t        }\n\t    });\n\t\n\t    var SINGLE_TOUCH_INPUT_MAP = {\n\t        touchstart: INPUT_START,\n\t        touchmove: INPUT_MOVE,\n\t        touchend: INPUT_END,\n\t        touchcancel: INPUT_CANCEL\n\t    };\n\t\n\t    var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\n\t    var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n\t\n\t    /**\r\n\t     * Touch events input\r\n\t     * @constructor\r\n\t     * @extends Input\r\n\t     */\n\t    function SingleTouchInput() {\n\t        this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n\t        this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n\t        this.started = false;\n\t\n\t        Input.apply(this, arguments);\n\t    }\n\t\n\t    inherit(SingleTouchInput, Input, {\n\t        handler: function TEhandler(ev) {\n\t            var type = SINGLE_TOUCH_INPUT_MAP[ev.type];\n\t\n\t            // should we handle the touch events?\n\t            if (type === INPUT_START) {\n\t                this.started = true;\n\t            }\n\t\n\t            if (!this.started) {\n\t                return;\n\t            }\n\t\n\t            var touches = normalizeSingleTouches.call(this, ev, type);\n\t\n\t            // when done, reset the started state\n\t            if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n\t                this.started = false;\n\t            }\n\t\n\t            this.callback(this.manager, type, {\n\t                pointers: touches[0],\n\t                changedPointers: touches[1],\n\t                pointerType: INPUT_TYPE_TOUCH,\n\t                srcEvent: ev\n\t            });\n\t        }\n\t    });\n\t\n\t    /**\r\n\t     * @this {TouchInput}\r\n\t     * @param {Object} ev\r\n\t     * @param {Number} type flag\r\n\t     * @returns {undefined|Array} [all, changed]\r\n\t     */\n\t    function normalizeSingleTouches(ev, type) {\n\t        var all = toArray(ev.touches);\n\t        var changed = toArray(ev.changedTouches);\n\t\n\t        if (type & (INPUT_END | INPUT_CANCEL)) {\n\t            all = uniqueArray(all.concat(changed), 'identifier', true);\n\t        }\n\t\n\t        return [all, changed];\n\t    }\n\t\n\t    var TOUCH_INPUT_MAP = {\n\t        touchstart: INPUT_START,\n\t        touchmove: INPUT_MOVE,\n\t        touchend: INPUT_END,\n\t        touchcancel: INPUT_CANCEL\n\t    };\n\t\n\t    var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n\t\n\t    /**\r\n\t     * Multi-user touch events input\r\n\t     * @constructor\r\n\t     * @extends Input\r\n\t     */\n\t    function TouchInput() {\n\t        this.evTarget = TOUCH_TARGET_EVENTS;\n\t        this.targetIds = {};\n\t\n\t        Input.apply(this, arguments);\n\t    }\n\t\n\t    inherit(TouchInput, Input, {\n\t        handler: function MTEhandler(ev) {\n\t            var type = TOUCH_INPUT_MAP[ev.type];\n\t            var touches = getTouches.call(this, ev, type);\n\t            if (!touches) {\n\t                return;\n\t            }\n\t\n\t            this.callback(this.manager, type, {\n\t                pointers: touches[0],\n\t                changedPointers: touches[1],\n\t                pointerType: INPUT_TYPE_TOUCH,\n\t                srcEvent: ev\n\t            });\n\t        }\n\t    });\n\t\n\t    /**\r\n\t     * @this {TouchInput}\r\n\t     * @param {Object} ev\r\n\t     * @param {Number} type flag\r\n\t     * @returns {undefined|Array} [all, changed]\r\n\t     */\n\t    function getTouches(ev, type) {\n\t        var allTouches = toArray(ev.touches);\n\t        var targetIds = this.targetIds;\n\t\n\t        // when there is only one touch, the process can be simplified\n\t        if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n\t            targetIds[allTouches[0].identifier] = true;\n\t            return [allTouches, allTouches];\n\t        }\n\t\n\t        var i,\n\t            targetTouches,\n\t            changedTouches = toArray(ev.changedTouches),\n\t            changedTargetTouches = [],\n\t            target = this.target;\n\t\n\t        // get target touches from touches\n\t        targetTouches = allTouches.filter(function (touch) {\n\t            return hasParent(touch.target, target);\n\t        });\n\t\n\t        // collect touches\n\t        if (type === INPUT_START) {\n\t            i = 0;\n\t            while (i < targetTouches.length) {\n\t                targetIds[targetTouches[i].identifier] = true;\n\t                i++;\n\t            }\n\t        }\n\t\n\t        // filter changed touches to only contain touches that exist in the collected target ids\n\t        i = 0;\n\t        while (i < changedTouches.length) {\n\t            if (targetIds[changedTouches[i].identifier]) {\n\t                changedTargetTouches.push(changedTouches[i]);\n\t            }\n\t\n\t            // cleanup removed touches\n\t            if (type & (INPUT_END | INPUT_CANCEL)) {\n\t                delete targetIds[changedTouches[i].identifier];\n\t            }\n\t            i++;\n\t        }\n\t\n\t        if (!changedTargetTouches.length) {\n\t            return;\n\t        }\n\t\n\t        return [\n\t        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n\t        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];\n\t    }\n\t\n\t    /**\r\n\t     * Combined touch and mouse input\r\n\t     *\r\n\t     * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\r\n\t     * This because touch devices also emit mouse events while doing a touch.\r\n\t     *\r\n\t     * @constructor\r\n\t     * @extends Input\r\n\t     */\n\t    function TouchMouseInput() {\n\t        Input.apply(this, arguments);\n\t\n\t        var handler = bindFn(this.handler, this);\n\t        this.touch = new TouchInput(this.manager, handler);\n\t        this.mouse = new MouseInput(this.manager, handler);\n\t    }\n\t\n\t    inherit(TouchMouseInput, Input, {\n\t        /**\r\n\t         * handle mouse and touch events\r\n\t         * @param {Hammer} manager\r\n\t         * @param {String} inputEvent\r\n\t         * @param {Object} inputData\r\n\t         */\n\t        handler: function TMEhandler(manager, inputEvent, inputData) {\n\t            var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH,\n\t                isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;\n\t\n\t            // when we're in a touch event, so  block all upcoming mouse events\n\t            // most mobile browser also emit mouseevents, right after touchstart\n\t            if (isTouch) {\n\t                this.mouse.allow = false;\n\t            } else if (isMouse && !this.mouse.allow) {\n\t                return;\n\t            }\n\t\n\t            // reset the allowMouse when we're done\n\t            if (inputEvent & (INPUT_END | INPUT_CANCEL)) {\n\t                this.mouse.allow = true;\n\t            }\n\t\n\t            this.callback(manager, inputEvent, inputData);\n\t        },\n\t\n\t        /**\r\n\t         * remove the event listeners\r\n\t         */\n\t        destroy: function destroy() {\n\t            this.touch.destroy();\n\t            this.mouse.destroy();\n\t        }\n\t    });\n\t\n\t    var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\n\t    var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\n\t\n\t    // magical touchAction value\n\t    var TOUCH_ACTION_COMPUTE = 'compute';\n\t    var TOUCH_ACTION_AUTO = 'auto';\n\t    var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\n\t    var TOUCH_ACTION_NONE = 'none';\n\t    var TOUCH_ACTION_PAN_X = 'pan-x';\n\t    var TOUCH_ACTION_PAN_Y = 'pan-y';\n\t\n\t    /**\r\n\t     * Touch Action\r\n\t     * sets the touchAction property or uses the js alternative\r\n\t     * @param {Manager} manager\r\n\t     * @param {String} value\r\n\t     * @constructor\r\n\t     */\n\t    function TouchAction(manager, value) {\n\t        this.manager = manager;\n\t        this.set(value);\n\t    }\n\t\n\t    TouchAction.prototype = {\n\t        /**\r\n\t         * set the touchAction value on the element or enable the polyfill\r\n\t         * @param {String} value\r\n\t         */\n\t        set: function set(value) {\n\t            // find out the touch-action by the event handlers\n\t            if (value == TOUCH_ACTION_COMPUTE) {\n\t                value = this.compute();\n\t            }\n\t\n\t            if (NATIVE_TOUCH_ACTION) {\n\t                this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n\t            }\n\t            this.actions = value.toLowerCase().trim();\n\t        },\n\t\n\t        /**\r\n\t         * just re-set the touchAction value\r\n\t         */\n\t        update: function update() {\n\t            this.set(this.manager.options.touchAction);\n\t        },\n\t\n\t        /**\r\n\t         * compute the value for the touchAction property based on the recognizer's settings\r\n\t         * @returns {String} value\r\n\t         */\n\t        compute: function compute() {\n\t            var actions = [];\n\t            each(this.manager.recognizers, function (recognizer) {\n\t                if (boolOrFn(recognizer.options.enable, [recognizer])) {\n\t                    actions = actions.concat(recognizer.getTouchAction());\n\t                }\n\t            });\n\t            return cleanTouchActions(actions.join(' '));\n\t        },\n\t\n\t        /**\r\n\t         * this method is called on each input cycle and provides the preventing of the browser behavior\r\n\t         * @param {Object} input\r\n\t         */\n\t        preventDefaults: function preventDefaults(input) {\n\t            // not needed with native support for the touchAction property\n\t            if (NATIVE_TOUCH_ACTION) {\n\t                return;\n\t            }\n\t\n\t            var srcEvent = input.srcEvent;\n\t            var direction = input.offsetDirection;\n\t\n\t            // if the touch action did prevented once this session\n\t            if (this.manager.session.prevented) {\n\t                srcEvent.preventDefault();\n\t                return;\n\t            }\n\t\n\t            var actions = this.actions;\n\t            var hasNone = inStr(actions, TOUCH_ACTION_NONE);\n\t            var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\n\t            var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n\t\n\t            if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {\n\t                return this.preventSrc(srcEvent);\n\t            }\n\t        },\n\t\n\t        /**\r\n\t         * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\r\n\t         * @param {Object} srcEvent\r\n\t         */\n\t        preventSrc: function preventSrc(srcEvent) {\n\t            this.manager.session.prevented = true;\n\t            srcEvent.preventDefault();\n\t        }\n\t    };\n\t\n\t    /**\r\n\t     * when the touchActions are collected they are not a valid value, so we need to clean things up. *\r\n\t     * @param {String} actions\r\n\t     * @returns {*}\r\n\t     */\n\t    function cleanTouchActions(actions) {\n\t        // none\n\t        if (inStr(actions, TOUCH_ACTION_NONE)) {\n\t            return TOUCH_ACTION_NONE;\n\t        }\n\t\n\t        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n\t        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\n\t\n\t        // pan-x and pan-y can be combined\n\t        if (hasPanX && hasPanY) {\n\t            return TOUCH_ACTION_PAN_X + ' ' + TOUCH_ACTION_PAN_Y;\n\t        }\n\t\n\t        // pan-x OR pan-y\n\t        if (hasPanX || hasPanY) {\n\t            return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n\t        }\n\t\n\t        // manipulation\n\t        if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n\t            return TOUCH_ACTION_MANIPULATION;\n\t        }\n\t\n\t        return TOUCH_ACTION_AUTO;\n\t    }\n\t\n\t    /**\r\n\t     * Recognizer flow explained; *\r\n\t     * All recognizers have the initial state of POSSIBLE when a input session starts.\r\n\t     * The definition of a input session is from the first input until the last input, with all it's movement in it. *\r\n\t     * Example session for mouse-input: mousedown -> mousemove -> mouseup\r\n\t     *\r\n\t     * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\r\n\t     * which determines with state it should be.\r\n\t     *\r\n\t     * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\r\n\t     * POSSIBLE to give it another change on the next cycle.\r\n\t     *\r\n\t     *               Possible\r\n\t     *                  |\r\n\t     *            +-----+---------------+\r\n\t     *            |                     |\r\n\t     *      +-----+-----+               |\r\n\t     *      |           |               |\r\n\t     *   Failed      Cancelled          |\r\n\t     *                          +-------+------+\r\n\t     *                          |              |\r\n\t     *                      Recognized       Began\r\n\t     *                                         |\r\n\t     *                                      Changed\r\n\t     *                                         |\r\n\t     *                                  Ended/Recognized\r\n\t     */\n\t    var STATE_POSSIBLE = 1;\n\t    var STATE_BEGAN = 2;\n\t    var STATE_CHANGED = 4;\n\t    var STATE_ENDED = 8;\n\t    var STATE_RECOGNIZED = STATE_ENDED;\n\t    var STATE_CANCELLED = 16;\n\t    var STATE_FAILED = 32;\n\t\n\t    /**\r\n\t     * Recognizer\r\n\t     * Every recognizer needs to extend from this class.\r\n\t     * @constructor\r\n\t     * @param {Object} options\r\n\t     */\n\t    function Recognizer(options) {\n\t        this.id = uniqueId();\n\t\n\t        this.manager = null;\n\t        this.options = merge(options || {}, this.defaults);\n\t\n\t        // default is enable true\n\t        this.options.enable = ifUndefined(this.options.enable, true);\n\t\n\t        this.state = STATE_POSSIBLE;\n\t\n\t        this.simultaneous = {};\n\t        this.requireFail = [];\n\t    }\n\t\n\t    Recognizer.prototype = {\n\t        /**\r\n\t         * @virtual\r\n\t         * @type {Object}\r\n\t         */\n\t        defaults: {},\n\t\n\t        /**\r\n\t         * set options\r\n\t         * @param {Object} options\r\n\t         * @return {Recognizer}\r\n\t         */\n\t        set: function set(options) {\n\t            extend(this.options, options);\n\t\n\t            // also update the touchAction, in case something changed about the directions/enabled state\n\t            this.manager && this.manager.touchAction.update();\n\t            return this;\n\t        },\n\t\n\t        /**\r\n\t         * recognize simultaneous with an other recognizer.\r\n\t         * @param {Recognizer} otherRecognizer\r\n\t         * @returns {Recognizer} this\r\n\t         */\n\t        recognizeWith: function recognizeWith(otherRecognizer) {\n\t            if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n\t                return this;\n\t            }\n\t\n\t            var simultaneous = this.simultaneous;\n\t            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n\t            if (!simultaneous[otherRecognizer.id]) {\n\t                simultaneous[otherRecognizer.id] = otherRecognizer;\n\t                otherRecognizer.recognizeWith(this);\n\t            }\n\t            return this;\n\t        },\n\t\n\t        /**\r\n\t         * drop the simultaneous link. it doesnt remove the link on the other recognizer.\r\n\t         * @param {Recognizer} otherRecognizer\r\n\t         * @returns {Recognizer} this\r\n\t         */\n\t        dropRecognizeWith: function dropRecognizeWith(otherRecognizer) {\n\t            if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n\t                return this;\n\t            }\n\t\n\t            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n\t            delete this.simultaneous[otherRecognizer.id];\n\t            return this;\n\t        },\n\t\n\t        /**\r\n\t         * recognizer can only run when an other is failing\r\n\t         * @param {Recognizer} otherRecognizer\r\n\t         * @returns {Recognizer} this\r\n\t         */\n\t        requireFailure: function requireFailure(otherRecognizer) {\n\t            if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n\t                return this;\n\t            }\n\t\n\t            var requireFail = this.requireFail;\n\t            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n\t            if (inArray(requireFail, otherRecognizer) === -1) {\n\t                requireFail.push(otherRecognizer);\n\t                otherRecognizer.requireFailure(this);\n\t            }\n\t            return this;\n\t        },\n\t\n\t        /**\r\n\t         * drop the requireFailure link. it does not remove the link on the other recognizer.\r\n\t         * @param {Recognizer} otherRecognizer\r\n\t         * @returns {Recognizer} this\r\n\t         */\n\t        dropRequireFailure: function dropRequireFailure(otherRecognizer) {\n\t            if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n\t                return this;\n\t            }\n\t\n\t            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n\t            var index = inArray(this.requireFail, otherRecognizer);\n\t            if (index > -1) {\n\t                this.requireFail.splice(index, 1);\n\t            }\n\t            return this;\n\t        },\n\t\n\t        /**\r\n\t         * has require failures boolean\r\n\t         * @returns {boolean}\r\n\t         */\n\t        hasRequireFailures: function hasRequireFailures() {\n\t            return this.requireFail.length > 0;\n\t        },\n\t\n\t        /**\r\n\t         * if the recognizer can recognize simultaneous with an other recognizer\r\n\t         * @param {Recognizer} otherRecognizer\r\n\t         * @returns {Boolean}\r\n\t         */\n\t        canRecognizeWith: function canRecognizeWith(otherRecognizer) {\n\t            return !!this.simultaneous[otherRecognizer.id];\n\t        },\n\t\n\t        /**\r\n\t         * You should use `tryEmit` instead of `emit` directly to check\r\n\t         * that all the needed recognizers has failed before emitting.\r\n\t         * @param {Object} input\r\n\t         */\n\t        emit: function emit(input) {\n\t            var self = this;\n\t            var state = this.state;\n\t\n\t            function emit(withState) {\n\t                self.manager.emit(self.options.event + (withState ? stateStr(state) : ''), input);\n\t            }\n\t\n\t            // 'panstart' and 'panmove'\n\t            if (state < STATE_ENDED) {\n\t                emit(true);\n\t            }\n\t\n\t            emit(); // simple 'eventName' events\n\t\n\t            // panend and pancancel\n\t            if (state >= STATE_ENDED) {\n\t                emit(true);\n\t            }\n\t        },\n\t\n\t        /**\r\n\t         * Check that all the require failure recognizers has failed,\r\n\t         * if true, it emits a gesture event,\r\n\t         * otherwise, setup the state to FAILED.\r\n\t         * @param {Object} input\r\n\t         */\n\t        tryEmit: function tryEmit(input) {\n\t            if (this.canEmit()) {\n\t                return this.emit(input);\n\t            }\n\t            // it's failing anyway\n\t            this.state = STATE_FAILED;\n\t        },\n\t\n\t        /**\r\n\t         * can we emit?\r\n\t         * @returns {boolean}\r\n\t         */\n\t        canEmit: function canEmit() {\n\t            var i = 0;\n\t            while (i < this.requireFail.length) {\n\t                if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n\t                    return false;\n\t                }\n\t                i++;\n\t            }\n\t            return true;\n\t        },\n\t\n\t        /**\r\n\t         * update the recognizer\r\n\t         * @param {Object} inputData\r\n\t         */\n\t        recognize: function recognize(inputData) {\n\t            // make a new copy of the inputData\n\t            // so we can change the inputData without messing up the other recognizers\n\t            var inputDataClone = extend({}, inputData);\n\t\n\t            // is is enabled and allow recognizing?\n\t            if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n\t                this.reset();\n\t                this.state = STATE_FAILED;\n\t                return;\n\t            }\n\t\n\t            // reset when we've reached the end\n\t            if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n\t                this.state = STATE_POSSIBLE;\n\t            }\n\t\n\t            this.state = this.process(inputDataClone);\n\t\n\t            // the recognizer has recognized a gesture\n\t            // so trigger an event\n\t            if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n\t                this.tryEmit(inputDataClone);\n\t            }\n\t        },\n\t\n\t        /**\r\n\t         * return the state of the recognizer\r\n\t         * the actual recognizing happens in this method\r\n\t         * @virtual\r\n\t         * @param {Object} inputData\r\n\t         * @returns {Const} STATE\r\n\t         */\n\t        process: function process(inputData) {}, // jshint ignore:line\n\t\n\t        /**\r\n\t         * return the preferred touch-action\r\n\t         * @virtual\r\n\t         * @returns {Array}\r\n\t         */\n\t        getTouchAction: function getTouchAction() {},\n\t\n\t        /**\r\n\t         * called when the gesture isn't allowed to recognize\r\n\t         * like when another is being recognized or it is disabled\r\n\t         * @virtual\r\n\t         */\n\t        reset: function reset() {}\n\t    };\n\t\n\t    /**\r\n\t     * get a usable string, used as event postfix\r\n\t     * @param {Const} state\r\n\t     * @returns {String} state\r\n\t     */\n\t    function stateStr(state) {\n\t        if (state & STATE_CANCELLED) {\n\t            return 'cancel';\n\t        } else if (state & STATE_ENDED) {\n\t            return 'end';\n\t        } else if (state & STATE_CHANGED) {\n\t            return 'move';\n\t        } else if (state & STATE_BEGAN) {\n\t            return 'start';\n\t        }\n\t        return '';\n\t    }\n\t\n\t    /**\r\n\t     * direction cons to string\r\n\t     * @param {Const} direction\r\n\t     * @returns {String}\r\n\t     */\n\t    function directionStr(direction) {\n\t        if (direction == DIRECTION_DOWN) {\n\t            return 'down';\n\t        } else if (direction == DIRECTION_UP) {\n\t            return 'up';\n\t        } else if (direction == DIRECTION_LEFT) {\n\t            return 'left';\n\t        } else if (direction == DIRECTION_RIGHT) {\n\t            return 'right';\n\t        }\n\t        return '';\n\t    }\n\t\n\t    /**\r\n\t     * get a recognizer by name if it is bound to a manager\r\n\t     * @param {Recognizer|String} otherRecognizer\r\n\t     * @param {Recognizer} recognizer\r\n\t     * @returns {Recognizer}\r\n\t     */\n\t    function getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n\t        var manager = recognizer.manager;\n\t        if (manager) {\n\t            return manager.get(otherRecognizer);\n\t        }\n\t        return otherRecognizer;\n\t    }\n\t\n\t    /**\r\n\t     * This recognizer is just used as a base for the simple attribute recognizers.\r\n\t     * @constructor\r\n\t     * @extends Recognizer\r\n\t     */\n\t    function AttrRecognizer() {\n\t        Recognizer.apply(this, arguments);\n\t    }\n\t\n\t    inherit(AttrRecognizer, Recognizer, {\n\t        /**\r\n\t         * @namespace\r\n\t         * @memberof AttrRecognizer\r\n\t         */\n\t        defaults: {\n\t            /**\r\n\t             * @type {Number}\r\n\t             * @default 1\r\n\t             */\n\t            pointers: 1\n\t        },\n\t\n\t        /**\r\n\t         * Used to check if it the recognizer receives valid input, like input.distance > 10.\r\n\t         * @memberof AttrRecognizer\r\n\t         * @param {Object} input\r\n\t         * @returns {Boolean} recognized\r\n\t         */\n\t        attrTest: function attrTest(input) {\n\t            var optionPointers = this.options.pointers;\n\t            return optionPointers === 0 || input.pointers.length === optionPointers;\n\t        },\n\t\n\t        /**\r\n\t         * Process the input and return the state for the recognizer\r\n\t         * @memberof AttrRecognizer\r\n\t         * @param {Object} input\r\n\t         * @returns {*} State\r\n\t         */\n\t        process: function process(input) {\n\t            var state = this.state;\n\t            var eventType = input.eventType;\n\t\n\t            var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n\t            var isValid = this.attrTest(input);\n\t\n\t            // on cancel input and we've recognized before, return STATE_CANCELLED\n\t            if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n\t                return state | STATE_CANCELLED;\n\t            } else if (isRecognized || isValid) {\n\t                if (eventType & INPUT_END) {\n\t                    return state | STATE_ENDED;\n\t                } else if (!(state & STATE_BEGAN)) {\n\t                    return STATE_BEGAN;\n\t                }\n\t                return state | STATE_CHANGED;\n\t            }\n\t            return STATE_FAILED;\n\t        }\n\t    });\n\t\n\t    /**\r\n\t     * Pan\r\n\t     * Recognized when the pointer is down and moved in the allowed direction.\r\n\t     * @constructor\r\n\t     * @extends AttrRecognizer\r\n\t     */\n\t    function PanRecognizer() {\n\t        AttrRecognizer.apply(this, arguments);\n\t\n\t        this.pX = null;\n\t        this.pY = null;\n\t    }\n\t\n\t    inherit(PanRecognizer, AttrRecognizer, {\n\t        /**\r\n\t         * @namespace\r\n\t         * @memberof PanRecognizer\r\n\t         */\n\t        defaults: {\n\t            event: 'pan',\n\t            threshold: 10,\n\t            pointers: 1,\n\t            direction: DIRECTION_ALL\n\t        },\n\t\n\t        getTouchAction: function getTouchAction() {\n\t            var direction = this.options.direction;\n\t            var actions = [];\n\t            if (direction & DIRECTION_HORIZONTAL) {\n\t                actions.push(TOUCH_ACTION_PAN_Y);\n\t            }\n\t            if (direction & DIRECTION_VERTICAL) {\n\t                actions.push(TOUCH_ACTION_PAN_X);\n\t            }\n\t            return actions;\n\t        },\n\t\n\t        directionTest: function directionTest(input) {\n\t            var options = this.options;\n\t            var hasMoved = true;\n\t            var distance = input.distance;\n\t            var direction = input.direction;\n\t            var x = input.deltaX;\n\t            var y = input.deltaY;\n\t\n\t            // lock to axis?\n\t            if (!(direction & options.direction)) {\n\t                if (options.direction & DIRECTION_HORIZONTAL) {\n\t                    direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n\t                    hasMoved = x != this.pX;\n\t                    distance = Math.abs(input.deltaX);\n\t                } else {\n\t                    direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n\t                    hasMoved = y != this.pY;\n\t                    distance = Math.abs(input.deltaY);\n\t                }\n\t            }\n\t            input.direction = direction;\n\t            return hasMoved && distance > options.threshold && direction & options.direction;\n\t        },\n\t\n\t        attrTest: function attrTest(input) {\n\t            return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));\n\t        },\n\t\n\t        emit: function emit(input) {\n\t            this.pX = input.deltaX;\n\t            this.pY = input.deltaY;\n\t\n\t            var direction = directionStr(input.direction);\n\t            if (direction) {\n\t                this.manager.emit(this.options.event + direction, input);\n\t            }\n\t\n\t            this._super.emit.call(this, input);\n\t        }\n\t    });\n\t\n\t    /**\r\n\t     * Pinch\r\n\t     * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\r\n\t     * @constructor\r\n\t     * @extends AttrRecognizer\r\n\t     */\n\t    function PinchRecognizer() {\n\t        AttrRecognizer.apply(this, arguments);\n\t    }\n\t\n\t    inherit(PinchRecognizer, AttrRecognizer, {\n\t        /**\r\n\t         * @namespace\r\n\t         * @memberof PinchRecognizer\r\n\t         */\n\t        defaults: {\n\t            event: 'pinch',\n\t            threshold: 0,\n\t            pointers: 2\n\t        },\n\t\n\t        getTouchAction: function getTouchAction() {\n\t            return [TOUCH_ACTION_NONE];\n\t        },\n\t\n\t        attrTest: function attrTest(input) {\n\t            return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n\t        },\n\t\n\t        emit: function emit(input) {\n\t            this._super.emit.call(this, input);\n\t            if (input.scale !== 1) {\n\t                var inOut = input.scale < 1 ? 'in' : 'out';\n\t                this.manager.emit(this.options.event + inOut, input);\n\t            }\n\t        }\n\t    });\n\t\n\t    /**\r\n\t     * Press\r\n\t     * Recognized when the pointer is down for x ms without any movement.\r\n\t     * @constructor\r\n\t     * @extends Recognizer\r\n\t     */\n\t    function PressRecognizer() {\n\t        Recognizer.apply(this, arguments);\n\t\n\t        this._timer = null;\n\t        this._input = null;\n\t    }\n\t\n\t    inherit(PressRecognizer, Recognizer, {\n\t        /**\r\n\t         * @namespace\r\n\t         * @memberof PressRecognizer\r\n\t         */\n\t        defaults: {\n\t            event: 'press',\n\t            pointers: 1,\n\t            time: 500, // minimal time of the pointer to be pressed\n\t            threshold: 5 // a minimal movement is ok, but keep it low\n\t        },\n\t\n\t        getTouchAction: function getTouchAction() {\n\t            return [TOUCH_ACTION_AUTO];\n\t        },\n\t\n\t        process: function process(input) {\n\t            var options = this.options;\n\t            var validPointers = input.pointers.length === options.pointers;\n\t            var validMovement = input.distance < options.threshold;\n\t            var validTime = input.deltaTime > options.time;\n\t\n\t            this._input = input;\n\t\n\t            // we only allow little movement\n\t            // and we've reached an end event, so a tap is possible\n\t            if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {\n\t                this.reset();\n\t            } else if (input.eventType & INPUT_START) {\n\t                this.reset();\n\t                this._timer = setTimeoutContext(function () {\n\t                    this.state = STATE_RECOGNIZED;\n\t                    this.tryEmit();\n\t                }, options.time, this);\n\t            } else if (input.eventType & INPUT_END) {\n\t                return STATE_RECOGNIZED;\n\t            }\n\t            return STATE_FAILED;\n\t        },\n\t\n\t        reset: function reset() {\n\t            clearTimeout(this._timer);\n\t        },\n\t\n\t        emit: function emit(input) {\n\t            if (this.state !== STATE_RECOGNIZED) {\n\t                return;\n\t            }\n\t\n\t            if (input && input.eventType & INPUT_END) {\n\t                this.manager.emit(this.options.event + 'up', input);\n\t            } else {\n\t                this._input.timeStamp = now();\n\t                this.manager.emit(this.options.event, this._input);\n\t            }\n\t        }\n\t    });\n\t\n\t    /**\r\n\t     * Rotate\r\n\t     * Recognized when two or more pointer are moving in a circular motion.\r\n\t     * @constructor\r\n\t     * @extends AttrRecognizer\r\n\t     */\n\t    function RotateRecognizer() {\n\t        AttrRecognizer.apply(this, arguments);\n\t    }\n\t\n\t    inherit(RotateRecognizer, AttrRecognizer, {\n\t        /**\r\n\t         * @namespace\r\n\t         * @memberof RotateRecognizer\r\n\t         */\n\t        defaults: {\n\t            event: 'rotate',\n\t            threshold: 0,\n\t            pointers: 2\n\t        },\n\t\n\t        getTouchAction: function getTouchAction() {\n\t            return [TOUCH_ACTION_NONE];\n\t        },\n\t\n\t        attrTest: function attrTest(input) {\n\t            return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n\t        }\n\t    });\n\t\n\t    /**\r\n\t     * Swipe\r\n\t     * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\r\n\t     * @constructor\r\n\t     * @extends AttrRecognizer\r\n\t     */\n\t    function SwipeRecognizer() {\n\t        AttrRecognizer.apply(this, arguments);\n\t    }\n\t\n\t    inherit(SwipeRecognizer, AttrRecognizer, {\n\t        /**\r\n\t         * @namespace\r\n\t         * @memberof SwipeRecognizer\r\n\t         */\n\t        defaults: {\n\t            event: 'swipe',\n\t            threshold: 10,\n\t            velocity: 0.65,\n\t            direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n\t            pointers: 1\n\t        },\n\t\n\t        getTouchAction: function getTouchAction() {\n\t            return PanRecognizer.prototype.getTouchAction.call(this);\n\t        },\n\t\n\t        attrTest: function attrTest(input) {\n\t            var direction = this.options.direction;\n\t            var velocity;\n\t\n\t            if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n\t                velocity = input.velocity;\n\t            } else if (direction & DIRECTION_HORIZONTAL) {\n\t                velocity = input.velocityX;\n\t            } else if (direction & DIRECTION_VERTICAL) {\n\t                velocity = input.velocityY;\n\t            }\n\t\n\t            return this._super.attrTest.call(this, input) && direction & input.direction && input.distance > this.options.threshold && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n\t        },\n\t\n\t        emit: function emit(input) {\n\t            var direction = directionStr(input.direction);\n\t            if (direction) {\n\t                this.manager.emit(this.options.event + direction, input);\n\t            }\n\t\n\t            this.manager.emit(this.options.event, input);\n\t        }\n\t    });\n\t\n\t    /**\r\n\t     * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\r\n\t     * between the given interval and position. The delay option can be used to recognize multi-taps without firing\r\n\t     * a single tap.\r\n\t     *\r\n\t     * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\r\n\t     * multi-taps being recognized.\r\n\t     * @constructor\r\n\t     * @extends Recognizer\r\n\t     */\n\t    function TapRecognizer() {\n\t        Recognizer.apply(this, arguments);\n\t\n\t        // previous time and center,\n\t        // used for tap counting\n\t        this.pTime = false;\n\t        this.pCenter = false;\n\t\n\t        this._timer = null;\n\t        this._input = null;\n\t        this.count = 0;\n\t    }\n\t\n\t    inherit(TapRecognizer, Recognizer, {\n\t        /**\r\n\t         * @namespace\r\n\t         * @memberof PinchRecognizer\r\n\t         */\n\t        defaults: {\n\t            event: 'tap',\n\t            pointers: 1,\n\t            taps: 1,\n\t            interval: 300, // max time between the multi-tap taps\n\t            time: 250, // max time of the pointer to be down (like finger on the screen)\n\t            threshold: 2, // a minimal movement is ok, but keep it low\n\t            posThreshold: 10 // a multi-tap can be a bit off the initial position\n\t        },\n\t\n\t        getTouchAction: function getTouchAction() {\n\t            return [TOUCH_ACTION_MANIPULATION];\n\t        },\n\t\n\t        process: function process(input) {\n\t            var options = this.options;\n\t\n\t            var validPointers = input.pointers.length === options.pointers;\n\t            var validMovement = input.distance < options.threshold;\n\t            var validTouchTime = input.deltaTime < options.time;\n\t\n\t            this.reset();\n\t\n\t            if (input.eventType & INPUT_START && this.count === 0) {\n\t                return this.failTimeout();\n\t            }\n\t\n\t            // we only allow little movement\n\t            // and we've reached an end event, so a tap is possible\n\t            if (validMovement && validTouchTime && validPointers) {\n\t                if (input.eventType != INPUT_END) {\n\t                    return this.failTimeout();\n\t                }\n\t\n\t                var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;\n\t                var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n\t\n\t                this.pTime = input.timeStamp;\n\t                this.pCenter = input.center;\n\t\n\t                if (!validMultiTap || !validInterval) {\n\t                    this.count = 1;\n\t                } else {\n\t                    this.count += 1;\n\t                }\n\t\n\t                this._input = input;\n\t\n\t                // if tap count matches we have recognized it,\n\t                // else it has began recognizing...\n\t                var tapCount = this.count % options.taps;\n\t                if (tapCount === 0) {\n\t                    // no failing requirements, immediately trigger the tap event\n\t                    // or wait as long as the multitap interval to trigger\n\t                    if (!this.hasRequireFailures()) {\n\t                        return STATE_RECOGNIZED;\n\t                    } else {\n\t                        this._timer = setTimeoutContext(function () {\n\t                            this.state = STATE_RECOGNIZED;\n\t                            this.tryEmit();\n\t                        }, options.interval, this);\n\t                        return STATE_BEGAN;\n\t                    }\n\t                }\n\t            }\n\t            return STATE_FAILED;\n\t        },\n\t\n\t        failTimeout: function failTimeout() {\n\t            this._timer = setTimeoutContext(function () {\n\t                this.state = STATE_FAILED;\n\t            }, this.options.interval, this);\n\t            return STATE_FAILED;\n\t        },\n\t\n\t        reset: function reset() {\n\t            clearTimeout(this._timer);\n\t        },\n\t\n\t        emit: function emit() {\n\t            if (this.state == STATE_RECOGNIZED) {\n\t                this._input.tapCount = this.count;\n\t                this.manager.emit(this.options.event, this._input);\n\t            }\n\t        }\n\t    });\n\t\n\t    /**\r\n\t     * Simple way to create an manager with a default set of recognizers.\r\n\t     * @param {HTMLElement} element\r\n\t     * @param {Object} [options]\r\n\t     * @constructor\r\n\t     */\n\t    function Hammer(element, options) {\n\t        options = options || {};\n\t        options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);\n\t        return new Manager(element, options);\n\t    }\n\t\n\t    /**\r\n\t     * @const {string}\r\n\t     */\n\t    Hammer.VERSION = '2.0.4';\n\t\n\t    /**\r\n\t     * default settings\r\n\t     * @namespace\r\n\t     */\n\t    Hammer.defaults = {\n\t        /**\r\n\t         * set if DOM events are being triggered.\r\n\t         * But this is slower and unused by simple implementations, so disabled by default.\r\n\t         * @type {Boolean}\r\n\t         * @default false\r\n\t         */\n\t        domEvents: false,\n\t\n\t        /**\r\n\t         * The value for the touchAction property/fallback.\r\n\t         * When set to `compute` it will magically set the correct value based on the added recognizers.\r\n\t         * @type {String}\r\n\t         * @default compute\r\n\t         */\n\t        touchAction: TOUCH_ACTION_COMPUTE,\n\t\n\t        /**\r\n\t         * @type {Boolean}\r\n\t         * @default true\r\n\t         */\n\t        enable: true,\n\t\n\t        /**\r\n\t         * EXPERIMENTAL FEATURE -- can be removed/changed\r\n\t         * Change the parent input target element.\r\n\t         * If Null, then it is being set the to main element.\r\n\t         * @type {Null|EventTarget}\r\n\t         * @default null\r\n\t         */\n\t        inputTarget: null,\n\t\n\t        /**\r\n\t         * force an input class\r\n\t         * @type {Null|Function}\r\n\t         * @default null\r\n\t         */\n\t        inputClass: null,\n\t\n\t        /**\r\n\t         * Default recognizer setup when calling `Hammer()`\r\n\t         * When creating a new Manager these will be skipped.\r\n\t         * @type {Array}\r\n\t         */\n\t        preset: [\n\t        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\n\t        [RotateRecognizer, { enable: false }], [PinchRecognizer, { enable: false }, ['rotate']], [SwipeRecognizer, { direction: DIRECTION_HORIZONTAL }], [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ['swipe']], [TapRecognizer], [TapRecognizer, { event: 'doubletap', taps: 2 }, ['tap']], [PressRecognizer]],\n\t\n\t        /**\r\n\t         * Some CSS properties can be used to improve the working of Hammer.\r\n\t         * Add them to this method and they will be set when creating a new Manager.\r\n\t         * @namespace\r\n\t         */\n\t        cssProps: {\n\t            /**\r\n\t             * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\r\n\t             * @type {String}\r\n\t             * @default 'none'\r\n\t             */\n\t            userSelect: 'none',\n\t\n\t            /**\r\n\t             * Disable the Windows Phone grippers when pressing an element.\r\n\t             * @type {String}\r\n\t             * @default 'none'\r\n\t             */\n\t            touchSelect: 'none',\n\t\n\t            /**\r\n\t             * Disables the default callout shown when you touch and hold a touch target.\r\n\t             * On iOS, when you touch and hold a touch target such as a link, Safari displays\r\n\t             * a callout containing information about the link. This property allows you to disable that callout.\r\n\t             * @type {String}\r\n\t             * @default 'none'\r\n\t             */\n\t            touchCallout: 'none',\n\t\n\t            /**\r\n\t             * Specifies whether zooming is enabled. Used by IE10>\r\n\t             * @type {String}\r\n\t             * @default 'none'\r\n\t             */\n\t            contentZooming: 'none',\n\t\n\t            /**\r\n\t             * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\r\n\t             * @type {String}\r\n\t             * @default 'none'\r\n\t             */\n\t            userDrag: 'none',\n\t\n\t            /**\r\n\t             * Overrides the highlight color shown when the user taps a link or a JavaScript\r\n\t             * clickable element in iOS. This property obeys the alpha value, if specified.\r\n\t             * @type {String}\r\n\t             * @default 'rgba(0,0,0,0)'\r\n\t             */\n\t            tapHighlightColor: 'rgba(0,0,0,0)'\n\t        }\n\t    };\n\t\n\t    var STOP = 1;\n\t    var FORCED_STOP = 2;\n\t\n\t    /**\r\n\t     * Manager\r\n\t     * @param {HTMLElement} element\r\n\t     * @param {Object} [options]\r\n\t     * @constructor\r\n\t     */\n\t    function Manager(element, options) {\n\t        options = options || {};\n\t\n\t        this.options = merge(options, Hammer.defaults);\n\t        this.options.inputTarget = this.options.inputTarget || element;\n\t\n\t        this.handlers = {};\n\t        this.session = {};\n\t        this.recognizers = [];\n\t\n\t        this.element = element;\n\t        this.input = createInputInstance(this);\n\t        this.touchAction = new TouchAction(this, this.options.touchAction);\n\t\n\t        toggleCssProps(this, true);\n\t\n\t        each(options.recognizers, function (item) {\n\t            var recognizer = this.add(new item[0](item[1]));\n\t            item[2] && recognizer.recognizeWith(item[2]);\n\t            item[3] && recognizer.requireFailure(item[3]);\n\t        }, this);\n\t    }\n\t\n\t    Manager.prototype = {\n\t        /**\r\n\t         * set options\r\n\t         * @param {Object} options\r\n\t         * @returns {Manager}\r\n\t         */\n\t        set: function set(options) {\n\t            extend(this.options, options);\n\t\n\t            // Options that need a little more setup\n\t            if (options.touchAction) {\n\t                this.touchAction.update();\n\t            }\n\t            if (options.inputTarget) {\n\t                // Clean up existing event listeners and reinitialize\n\t                this.input.destroy();\n\t                this.input.target = options.inputTarget;\n\t                this.input.init();\n\t            }\n\t            return this;\n\t        },\n\t\n\t        /**\r\n\t         * stop recognizing for this session.\r\n\t         * This session will be discarded, when a new [input]start event is fired.\r\n\t         * When forced, the recognizer cycle is stopped immediately.\r\n\t         * @param {Boolean} [force]\r\n\t         */\n\t        stop: function stop(force) {\n\t            this.session.stopped = force ? FORCED_STOP : STOP;\n\t        },\n\t\n\t        /**\r\n\t         * run the recognizers!\r\n\t         * called by the inputHandler function on every movement of the pointers (touches)\r\n\t         * it walks through all the recognizers and tries to detect the gesture that is being made\r\n\t         * @param {Object} inputData\r\n\t         */\n\t        recognize: function recognize(inputData) {\n\t            var session = this.session;\n\t            if (session.stopped) {\n\t                return;\n\t            }\n\t\n\t            // run the touch-action polyfill\n\t            this.touchAction.preventDefaults(inputData);\n\t\n\t            var recognizer;\n\t            var recognizers = this.recognizers;\n\t\n\t            // this holds the recognizer that is being recognized.\n\t            // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n\t            // if no recognizer is detecting a thing, it is set to `null`\n\t            var curRecognizer = session.curRecognizer;\n\t\n\t            // reset when the last recognizer is recognized\n\t            // or when we're in a new session\n\t            if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {\n\t                curRecognizer = session.curRecognizer = null;\n\t            }\n\t\n\t            var i = 0;\n\t            while (i < recognizers.length) {\n\t                recognizer = recognizers[i];\n\t\n\t                // find out if we are allowed try to recognize the input for this one.\n\t                // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n\t                // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n\t                //      that is being recognized.\n\t                // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n\t                //      this can be setup with the `recognizeWith()` method on the recognizer.\n\t                if (session.stopped !== FORCED_STOP && ( // 1\n\t                !curRecognizer || recognizer == curRecognizer || // 2\n\t                recognizer.canRecognizeWith(curRecognizer))) {\n\t                    // 3\n\t                    recognizer.recognize(inputData);\n\t                } else {\n\t                    recognizer.reset();\n\t                }\n\t\n\t                // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n\t                // current active recognizer. but only if we don't already have an active recognizer\n\t                if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n\t                    curRecognizer = session.curRecognizer = recognizer;\n\t                }\n\t                i++;\n\t            }\n\t        },\n\t\n\t        /**\r\n\t         * get a recognizer by its event name.\r\n\t         * @param {Recognizer|String} recognizer\r\n\t         * @returns {Recognizer|Null}\r\n\t         */\n\t        get: function get(recognizer) {\n\t            if (recognizer instanceof Recognizer) {\n\t                return recognizer;\n\t            }\n\t\n\t            var recognizers = this.recognizers;\n\t            for (var i = 0; i < recognizers.length; i++) {\n\t                if (recognizers[i].options.event == recognizer) {\n\t                    return recognizers[i];\n\t                }\n\t            }\n\t            return null;\n\t        },\n\t\n\t        /**\r\n\t         * add a recognizer to the manager\r\n\t         * existing recognizers with the same event name will be removed\r\n\t         * @param {Recognizer} recognizer\r\n\t         * @returns {Recognizer|Manager}\r\n\t         */\n\t        add: function add(recognizer) {\n\t            if (invokeArrayArg(recognizer, 'add', this)) {\n\t                return this;\n\t            }\n\t\n\t            // remove existing\n\t            var existing = this.get(recognizer.options.event);\n\t            if (existing) {\n\t                this.remove(existing);\n\t            }\n\t\n\t            this.recognizers.push(recognizer);\n\t            recognizer.manager = this;\n\t\n\t            this.touchAction.update();\n\t            return recognizer;\n\t        },\n\t\n\t        /**\r\n\t         * remove a recognizer by name or instance\r\n\t         * @param {Recognizer|String} recognizer\r\n\t         * @returns {Manager}\r\n\t         */\n\t        remove: function remove(recognizer) {\n\t            if (invokeArrayArg(recognizer, 'remove', this)) {\n\t                return this;\n\t            }\n\t\n\t            var recognizers = this.recognizers;\n\t            recognizer = this.get(recognizer);\n\t            recognizers.splice(inArray(recognizers, recognizer), 1);\n\t\n\t            this.touchAction.update();\n\t            return this;\n\t        },\n\t\n\t        /**\r\n\t         * bind event\r\n\t         * @param {String} events\r\n\t         * @param {Function} handler\r\n\t         * @returns {EventEmitter} this\r\n\t         */\n\t        on: function on(events, handler) {\n\t            var handlers = this.handlers;\n\t            each(splitStr(events), function (event) {\n\t                handlers[event] = handlers[event] || [];\n\t                handlers[event].push(handler);\n\t            });\n\t            return this;\n\t        },\n\t\n\t        /**\r\n\t         * unbind event, leave emit blank to remove all handlers\r\n\t         * @param {String} events\r\n\t         * @param {Function} [handler]\r\n\t         * @returns {EventEmitter} this\r\n\t         */\n\t        off: function off(events, handler) {\n\t            var handlers = this.handlers;\n\t            each(splitStr(events), function (event) {\n\t                if (!handler) {\n\t                    delete handlers[event];\n\t                } else {\n\t                    handlers[event].splice(inArray(handlers[event], handler), 1);\n\t                }\n\t            });\n\t            return this;\n\t        },\n\t\n\t        /**\r\n\t         * emit event to the listeners\r\n\t         * @param {String} event\r\n\t         * @param {Object} data\r\n\t         */\n\t        emit: function emit(event, data) {\n\t            // we also want to trigger dom events\n\t            if (this.options.domEvents) {\n\t                triggerDomEvent(event, data);\n\t            }\n\t\n\t            // no handlers, so skip it all\n\t            var handlers = this.handlers[event] && this.handlers[event].slice();\n\t            if (!handlers || !handlers.length) {\n\t                return;\n\t            }\n\t\n\t            data.type = event;\n\t            data.preventDefault = function () {\n\t                data.srcEvent.preventDefault();\n\t            };\n\t\n\t            var i = 0;\n\t            while (i < handlers.length) {\n\t                handlers[i](data);\n\t                i++;\n\t            }\n\t        },\n\t\n\t        /**\r\n\t         * destroy the manager and unbinds all events\r\n\t         * it doesn't unbind dom events, that is the user own responsibility\r\n\t         */\n\t        destroy: function destroy() {\n\t            this.element && toggleCssProps(this, false);\n\t\n\t            this.handlers = {};\n\t            this.session = {};\n\t            this.input.destroy();\n\t            this.element = null;\n\t        }\n\t    };\n\t\n\t    /**\r\n\t     * add/remove the css properties as defined in manager.options.cssProps\r\n\t     * @param {Manager} manager\r\n\t     * @param {Boolean} add\r\n\t     */\n\t    function toggleCssProps(manager, add) {\n\t        var element = manager.element;\n\t        each(manager.options.cssProps, function (value, name) {\n\t            element.style[prefixed(element.style, name)] = add ? value : '';\n\t        });\n\t    }\n\t\n\t    /**\r\n\t     * trigger dom event\r\n\t     * @param {String} event\r\n\t     * @param {Object} data\r\n\t     */\n\t    function triggerDomEvent(event, data) {\n\t        var gestureEvent = document.createEvent('Event');\n\t        gestureEvent.initEvent(event, true, true);\n\t        gestureEvent.gesture = data;\n\t        data.target.dispatchEvent(gestureEvent);\n\t    }\n\t\n\t    extend(Hammer, {\n\t        INPUT_START: INPUT_START,\n\t        INPUT_MOVE: INPUT_MOVE,\n\t        INPUT_END: INPUT_END,\n\t        INPUT_CANCEL: INPUT_CANCEL,\n\t\n\t        STATE_POSSIBLE: STATE_POSSIBLE,\n\t        STATE_BEGAN: STATE_BEGAN,\n\t        STATE_CHANGED: STATE_CHANGED,\n\t        STATE_ENDED: STATE_ENDED,\n\t        STATE_RECOGNIZED: STATE_RECOGNIZED,\n\t        STATE_CANCELLED: STATE_CANCELLED,\n\t        STATE_FAILED: STATE_FAILED,\n\t\n\t        DIRECTION_NONE: DIRECTION_NONE,\n\t        DIRECTION_LEFT: DIRECTION_LEFT,\n\t        DIRECTION_RIGHT: DIRECTION_RIGHT,\n\t        DIRECTION_UP: DIRECTION_UP,\n\t        DIRECTION_DOWN: DIRECTION_DOWN,\n\t        DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,\n\t        DIRECTION_VERTICAL: DIRECTION_VERTICAL,\n\t        DIRECTION_ALL: DIRECTION_ALL,\n\t\n\t        Manager: Manager,\n\t        Input: Input,\n\t        TouchAction: TouchAction,\n\t\n\t        TouchInput: TouchInput,\n\t        MouseInput: MouseInput,\n\t        PointerEventInput: PointerEventInput,\n\t        TouchMouseInput: TouchMouseInput,\n\t        SingleTouchInput: SingleTouchInput,\n\t\n\t        Recognizer: Recognizer,\n\t        AttrRecognizer: AttrRecognizer,\n\t        Tap: TapRecognizer,\n\t        Pan: PanRecognizer,\n\t        Swipe: SwipeRecognizer,\n\t        Pinch: PinchRecognizer,\n\t        Rotate: RotateRecognizer,\n\t        Press: PressRecognizer,\n\t\n\t        on: addEventListeners,\n\t        off: removeEventListeners,\n\t        each: each,\n\t        merge: merge,\n\t        extend: extend,\n\t        inherit: inherit,\n\t        bindFn: bindFn,\n\t        prefixed: prefixed\n\t    });\n\t\n\t    if (( false ? 'undefined' : _typeof(__webpack_require__(4))) == TYPE_FUNCTION && __webpack_require__(5)) {\n\t        !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {\n\t            return Hammer;\n\t        }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    } else if (typeof module != 'undefined' && module.exports) {\n\t        module.exports = Hammer;\n\t    } else {\n\t        window[exportName] = Hammer;\n\t    }\n\t})(window, document, 'Hammer');\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function() { throw new Error(\"define cannot be used indirect\"); };\r\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__;\r\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, {}))\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** auru.notouch.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 5229cb3848dfe50baad5\n **/","'use strict';\n\nvar EventEmitter = require('eventemitter3');\nvar Hammer;\nvar touchEnabled = typeof AURU_TOUCH_ENABLED === 'undefined' || AURU_TOUCH_ENABLED === true;\nif (touchEnabled) {\n\tHammer = require('hammerjs');\n}\n\nvar defaultOptions = {\n\tslideDuration: 5, // how many seconds to show each slide, false to not play automatically\n\tclassPrefix: 'auru-',\n\tcontinuousLoop: true,\n\ttouch: false\n};\n\nfunction dumbMerge(first, second) {\n\tvar copy = {};\n\tfor (var key in first) {\n\t\tcopy[key] = first[key];\n\t}\n\tfor (var key in second) {\n\t\tcopy[key] = second[key];\n\t}\n\treturn copy;\n}\n\nexport default class Auru extends EventEmitter {\n\tconstructor(element, options) {\n\t\tsuper();\n\t\tthis.element = element;\n\t\tthis.options = dumbMerge(defaultOptions, options || {});\n\n\t\tthis.playing = false;\n\t\tthis.currentIndex = 0;\n\t\tthis.maxIndex = this.element.children.length - 1;\n\t\tthis.previousSlide = this.element.children[this.maxIndex];\n\t\tthis.currentSlide = this.element.children[this.currentIndex];\n\n\t\tthis._initializeClasses();\n\n\t\tif (touchEnabled && this.options.touch) {\n\t\t\tthis._initializeTouchEvents();\n\t\t}\n\n\t\tif (this.options.slideDuration) {\n\t\t\tthis.play();\n\t\t}\n\t}\n\t_initializeClasses() {\n\t\tvar prefix = this.options.classPrefix, i = 0;\n\t\tthis.element.classList.add(prefix + 'slideshow');\n\t\tArray.prototype.forEach.call(this.element.children, childNode => {\n\t\t\tchildNode.classList.add(prefix + 'slide');\n\t\t\tif (i === 0) {\n\t\t\t\tchildNode.classList.add(prefix + 'current');\n\t\t\t} else {\n\t\t\t\tchildNode.classList.add(prefix + 'hidden');\n\t\t\t}\n\t\t\ti++;\n\t\t});\n\t}\n\t_removeClasses() {\n\t\tvar prefix = this.options.classPrefix, i = 0;\n\t\tthis.element.classList.remove(prefix + 'slideshow');\n\t\tArray.prototype.forEach.call(this.element.children, childNode => {\n\t\t\tchildNode.classList.remove(\n\t\t\t\tprefix + 'slide',\n\t\t\t\tprefix + 'current',\n\t\t\t\tprefix + 'previous',\n\t\t\t\tprefix + 'to-right',\n\t\t\t\tprefix + 'to-left',\n\t\t\t\tprefix + 'from-right',\n\t\t\t\tprefix + 'from-left'\n\t\t\t);\n\t\t\ti++;\n\t\t});\n\t}\n\t_initializeTouchEvents() {\n\t\tthis.hammer = new Hammer(this.element);\n\t\tthis.hammer.on('swipeleft', () => {\n\t\t\tthis.next();\n\t\t\tthis.emit('swipe');\n\t\t\tthis.emit('swipeleft');\n\t\t});\n\t\tthis.hammer.on('swiperight', () => {\n\t\t\tthis.previous();\n\t\t\tthis.emit('swipe');\n\t\t\tthis.emit('swiperight');\n\t\t});\n\t\tthis.hammer.on('tap', () => {\n\t\t\tthis.emit('tap');\n\t\t});\n\t}\n\t_removeAnimationClasses(elem) {\n\t\tvar prefix = this.options.classPrefix;\n\t\telem.classList.remove(\n\t\t\tprefix + 'to-right',\n\t\t\tprefix + 'to-left',\n\t\t\tprefix + 'from-right',\n\t\t\tprefix + 'from-left'\n\t\t);\n\t}\n\tplay() {\n\t\tif (this.playing || typeof this.options.slideDuration !== 'number' || this.options.slideDuration <= 0) {\n\t\t\treturn;\n\t\t}\n\t\tthis.playing = true;\n\t\tthis.timer = setInterval(this.next.bind(this), this.options.slideDuration*1000);\n\t}\n\tstop() {\n\t\tthis.playing = false;\n\t\tclearInterval(this.timer);\n\t}\n\tnext() {\n\t\tvar nextIndex = this.currentIndex+1;\n\t\tif (nextIndex > this.maxIndex) {\n\t\t\tnextIndex = 0;\n\t\t}\n\t\treturn this.goToSlide(nextIndex);\n\t}\n\tprevious() {\n\t\tvar nextIndex = this.currentIndex-1;\n\t\tif (nextIndex < 0) {\n\t\t\tnextIndex = this.maxIndex;\n\t\t}\n\t\treturn this.goToSlide(nextIndex);\n\t}\n\tgoToSlide(index) {\n\t\tvar prefix, children, oldPrevious, previous, current, oldIndex;\n\n\t\tif (index < 0 || index > this.maxIndex) {\n\t\t\tthrow new TypeError('Slide index out of bounds');\n\t\t}\n\n\t\tif (index === this.currentIndex) {\n\t\t\treturn;\n\t\t}\n\n\t\tprefix = this.options.classPrefix;\n\t\tchildren = this.element.children;\n\n\t\toldPrevious = this.previousSlide;\n\t\tprevious = this.currentSlide;\n\n\t\toldIndex = this.currentIndex;\n\t\tthis.currentIndex = index;\n\t\tcurrent = children[index];\n\n\t\tthis._removeAnimationClasses(oldPrevious);\n\t\toldPrevious.classList.remove(prefix + 'previous');\n\t\toldPrevious.classList.add(prefix + 'hidden');\n\n\t\tthis._removeAnimationClasses(previous);\n\t\tprevious.classList.remove(prefix + 'current');\n\t\tprevious.classList.add(prefix + 'previous');\n\t\tif (this.options.continuousLoop && this.currentIndex === 0 && oldIndex === this.maxIndex) {\n\t\t\tprevious.classList.add(prefix + 'to-left');\n\t\t} else if (this.options.continuousLoop && this.currentIndex === this.maxIndex && oldIndex === 0) {\n\t\t\tprevious.classList.add(prefix + 'to-right');\n\t\t} else if (this.currentIndex > oldIndex) {\n\t\t\tprevious.classList.add(prefix + 'to-left');\n\t\t} else {\n\t\t\tprevious.classList.add(prefix + 'to-right');\n\t\t}\n\n\t\tcurrent.classList.remove(prefix + 'hidden');\n\t\tcurrent.classList.add(prefix + 'current');\n\t\tif (this.options.continuousLoop && this.currentIndex === 0 && oldIndex === this.maxIndex) {\n\t\t\tcurrent.classList.add(prefix + 'from-right');\n\t\t} else if (this.options.continuousLoop && this.currentIndex === this.maxIndex && oldIndex === 0) {\n\t\t\tcurrent.classList.add(prefix + 'from-left');\n\t\t} else if (this.currentIndex > oldIndex) {\n\t\t\tcurrent.classList.add(prefix + 'from-right');\n\t\t} else {\n\t\t\tcurrent.classList.add(prefix + 'from-left');\n\t\t}\n\n\t\tthis.previousSlide = previous;\n\t\tthis.currentSlide = current;\n\n\t\tthis.emit('change');\n\t}\n\tdestroy(removeClasses) {\n\t\tvar prefix;\n\t\tif (touchEnabled && this.options.touch) {\n\t\t\tthis.hammer.destroy();\n\t\t}\n\t\tif (removeClasses) {\n\t\t\tthis._removeClasses();\n\t\t}\n\t\tthis.stop();\n\t\tthis.removeAllListeners();\n\t}\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./auru.js\n **/","'use strict';\n\n//\n// We store our EE objects in a plain object whose properties are event names.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// `~` to make sure that the built-in object properties are not overridden or\n// used as an attack vector.\n// We also assume that `Object.create(null)` is available when the event name\n// is an ES6 Symbol.\n//\nvar prefix = typeof Object.create !== 'function' ? '~' : false;\n\n/**\n * Representation of a single EventEmitter function.\n *\n * @param {Function} fn Event handler to be called.\n * @param {Mixed} context Context for function execution.\n * @param {Boolean} once Only emit once\n * @api private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Minimal EventEmitter interface that is molded against the Node.js\n * EventEmitter interface.\n *\n * @constructor\n * @api public\n */\nfunction EventEmitter() { /* Nothing to set */ }\n\n/**\n * Holds the assigned EventEmitters by name.\n *\n * @type {Object}\n * @private\n */\nEventEmitter.prototype._events = undefined;\n\n/**\n * Return a list of assigned event listeners.\n *\n * @param {String} event The events that should be listed.\n * @param {Boolean} exists We only need to know if there are listeners.\n * @returns {Array|Boolean}\n * @api public\n */\nEventEmitter.prototype.listeners = function listeners(event, exists) {\n  var evt = prefix ? prefix + event : event\n    , available = this._events && this._events[evt];\n\n  if (exists) return !!available;\n  if (!available) return [];\n  if (available.fn) return [available.fn];\n\n  for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {\n    ee[i] = available[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Emit an event to all registered event listeners.\n *\n * @param {String} event The name of the event.\n * @returns {Boolean} Indication if we've emitted an event.\n * @api public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events || !this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if ('function' === typeof listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Register a new EventListener for the given event.\n *\n * @param {String} event Name of the event.\n * @param {Functon} fn Callback function.\n * @param {Mixed} context The context of the function.\n * @api public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  var listener = new EE(fn, context || this)\n    , evt = prefix ? prefix + event : event;\n\n  if (!this._events) this._events = prefix ? {} : Object.create(null);\n  if (!this._events[evt]) this._events[evt] = listener;\n  else {\n    if (!this._events[evt].fn) this._events[evt].push(listener);\n    else this._events[evt] = [\n      this._events[evt], listener\n    ];\n  }\n\n  return this;\n};\n\n/**\n * Add an EventListener that's only called once.\n *\n * @param {String} event Name of the event.\n * @param {Function} fn Callback function.\n * @param {Mixed} context The context of the function.\n * @api public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  var listener = new EE(fn, context || this, true)\n    , evt = prefix ? prefix + event : event;\n\n  if (!this._events) this._events = prefix ? {} : Object.create(null);\n  if (!this._events[evt]) this._events[evt] = listener;\n  else {\n    if (!this._events[evt].fn) this._events[evt].push(listener);\n    else this._events[evt] = [\n      this._events[evt], listener\n    ];\n  }\n\n  return this;\n};\n\n/**\n * Remove event listeners.\n *\n * @param {String} event The event we want to remove.\n * @param {Function} fn The listener that we need to find.\n * @param {Mixed} context Only remove listeners matching this context.\n * @param {Boolean} once Only remove once listeners.\n * @api public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events || !this._events[evt]) return this;\n\n  var listeners = this._events[evt]\n    , events = [];\n\n  if (fn) {\n    if (listeners.fn) {\n      if (\n           listeners.fn !== fn\n        || (once && !listeners.once)\n        || (context && listeners.context !== context)\n      ) {\n        events.push(listeners);\n      }\n    } else {\n      for (var i = 0, length = listeners.length; i < length; i++) {\n        if (\n             listeners[i].fn !== fn\n          || (once && !listeners[i].once)\n          || (context && listeners[i].context !== context)\n        ) {\n          events.push(listeners[i]);\n        }\n      }\n    }\n  }\n\n  //\n  // Reset the array, or remove it completely if we have no more listeners.\n  //\n  if (events.length) {\n    this._events[evt] = events.length === 1 ? events[0] : events;\n  } else {\n    delete this._events[evt];\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners or only the listeners for the specified event.\n *\n * @param {String} event The event want to remove all listeners for.\n * @api public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  if (!this._events) return this;\n\n  if (event) delete this._events[prefix ? prefix + event : event];\n  else this._events = prefix ? {} : Object.create(null);\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// This function doesn't apply anymore.\n//\nEventEmitter.prototype.setMaxListeners = function setMaxListeners() {\n  return this;\n};\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eventemitter3/index.js\n **/","/*! Hammer.JS - v2.0.4 - 2014-09-28\r\n * http://hammerjs.github.io/\r\n *\r\n * Copyright (c) 2014 Jorik Tangelder;\r\n * Licensed under the MIT license */\r\n(function(window, document, exportName, undefined) {\r\n  'use strict';\r\n\r\nvar VENDOR_PREFIXES = ['', 'webkit', 'moz', 'MS', 'ms', 'o'];\r\nvar TEST_ELEMENT = document.createElement('div');\r\n\r\nvar TYPE_FUNCTION = 'function';\r\n\r\nvar round = Math.round;\r\nvar abs = Math.abs;\r\nvar now = Date.now;\r\n\r\n/**\r\n * set a timeout with a given scope\r\n * @param {Function} fn\r\n * @param {Number} timeout\r\n * @param {Object} context\r\n * @returns {number}\r\n */\r\nfunction setTimeoutContext(fn, timeout, context) {\r\n    return setTimeout(bindFn(fn, context), timeout);\r\n}\r\n\r\n/**\r\n * if the argument is an array, we want to execute the fn on each entry\r\n * if it aint an array we don't want to do a thing.\r\n * this is used by all the methods that accept a single and array argument.\r\n * @param {*|Array} arg\r\n * @param {String} fn\r\n * @param {Object} [context]\r\n * @returns {Boolean}\r\n */\r\nfunction invokeArrayArg(arg, fn, context) {\r\n    if (Array.isArray(arg)) {\r\n        each(arg, context[fn], context);\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * walk objects and arrays\r\n * @param {Object} obj\r\n * @param {Function} iterator\r\n * @param {Object} context\r\n */\r\nfunction each(obj, iterator, context) {\r\n    var i;\r\n\r\n    if (!obj) {\r\n        return;\r\n    }\r\n\r\n    if (obj.forEach) {\r\n        obj.forEach(iterator, context);\r\n    } else if (obj.length !== undefined) {\r\n        i = 0;\r\n        while (i < obj.length) {\r\n            iterator.call(context, obj[i], i, obj);\r\n            i++;\r\n        }\r\n    } else {\r\n        for (i in obj) {\r\n            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * extend object.\r\n * means that properties in dest will be overwritten by the ones in src.\r\n * @param {Object} dest\r\n * @param {Object} src\r\n * @param {Boolean} [merge]\r\n * @returns {Object} dest\r\n */\r\nfunction extend(dest, src, merge) {\r\n    var keys = Object.keys(src);\r\n    var i = 0;\r\n    while (i < keys.length) {\r\n        if (!merge || (merge && dest[keys[i]] === undefined)) {\r\n            dest[keys[i]] = src[keys[i]];\r\n        }\r\n        i++;\r\n    }\r\n    return dest;\r\n}\r\n\r\n/**\r\n * merge the values from src in the dest.\r\n * means that properties that exist in dest will not be overwritten by src\r\n * @param {Object} dest\r\n * @param {Object} src\r\n * @returns {Object} dest\r\n */\r\nfunction merge(dest, src) {\r\n    return extend(dest, src, true);\r\n}\r\n\r\n/**\r\n * simple class inheritance\r\n * @param {Function} child\r\n * @param {Function} base\r\n * @param {Object} [properties]\r\n */\r\nfunction inherit(child, base, properties) {\r\n    var baseP = base.prototype,\r\n        childP;\r\n\r\n    childP = child.prototype = Object.create(baseP);\r\n    childP.constructor = child;\r\n    childP._super = baseP;\r\n\r\n    if (properties) {\r\n        extend(childP, properties);\r\n    }\r\n}\r\n\r\n/**\r\n * simple function bind\r\n * @param {Function} fn\r\n * @param {Object} context\r\n * @returns {Function}\r\n */\r\nfunction bindFn(fn, context) {\r\n    return function boundFn() {\r\n        return fn.apply(context, arguments);\r\n    };\r\n}\r\n\r\n/**\r\n * let a boolean value also be a function that must return a boolean\r\n * this first item in args will be used as the context\r\n * @param {Boolean|Function} val\r\n * @param {Array} [args]\r\n * @returns {Boolean}\r\n */\r\nfunction boolOrFn(val, args) {\r\n    if (typeof val == TYPE_FUNCTION) {\r\n        return val.apply(args ? args[0] || undefined : undefined, args);\r\n    }\r\n    return val;\r\n}\r\n\r\n/**\r\n * use the val2 when val1 is undefined\r\n * @param {*} val1\r\n * @param {*} val2\r\n * @returns {*}\r\n */\r\nfunction ifUndefined(val1, val2) {\r\n    return (val1 === undefined) ? val2 : val1;\r\n}\r\n\r\n/**\r\n * addEventListener with multiple events at once\r\n * @param {EventTarget} target\r\n * @param {String} types\r\n * @param {Function} handler\r\n */\r\nfunction addEventListeners(target, types, handler) {\r\n    each(splitStr(types), function(type) {\r\n        target.addEventListener(type, handler, false);\r\n    });\r\n}\r\n\r\n/**\r\n * removeEventListener with multiple events at once\r\n * @param {EventTarget} target\r\n * @param {String} types\r\n * @param {Function} handler\r\n */\r\nfunction removeEventListeners(target, types, handler) {\r\n    each(splitStr(types), function(type) {\r\n        target.removeEventListener(type, handler, false);\r\n    });\r\n}\r\n\r\n/**\r\n * find if a node is in the given parent\r\n * @method hasParent\r\n * @param {HTMLElement} node\r\n * @param {HTMLElement} parent\r\n * @return {Boolean} found\r\n */\r\nfunction hasParent(node, parent) {\r\n    while (node) {\r\n        if (node == parent) {\r\n            return true;\r\n        }\r\n        node = node.parentNode;\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * small indexOf wrapper\r\n * @param {String} str\r\n * @param {String} find\r\n * @returns {Boolean} found\r\n */\r\nfunction inStr(str, find) {\r\n    return str.indexOf(find) > -1;\r\n}\r\n\r\n/**\r\n * split string on whitespace\r\n * @param {String} str\r\n * @returns {Array} words\r\n */\r\nfunction splitStr(str) {\r\n    return str.trim().split(/\\s+/g);\r\n}\r\n\r\n/**\r\n * find if a array contains the object using indexOf or a simple polyFill\r\n * @param {Array} src\r\n * @param {String} find\r\n * @param {String} [findByKey]\r\n * @return {Boolean|Number} false when not found, or the index\r\n */\r\nfunction inArray(src, find, findByKey) {\r\n    if (src.indexOf && !findByKey) {\r\n        return src.indexOf(find);\r\n    } else {\r\n        var i = 0;\r\n        while (i < src.length) {\r\n            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {\r\n                return i;\r\n            }\r\n            i++;\r\n        }\r\n        return -1;\r\n    }\r\n}\r\n\r\n/**\r\n * convert array-like objects to real arrays\r\n * @param {Object} obj\r\n * @returns {Array}\r\n */\r\nfunction toArray(obj) {\r\n    return Array.prototype.slice.call(obj, 0);\r\n}\r\n\r\n/**\r\n * unique array with objects based on a key (like 'id') or just by the array's value\r\n * @param {Array} src [{id:1},{id:2},{id:1}]\r\n * @param {String} [key]\r\n * @param {Boolean} [sort=False]\r\n * @returns {Array} [{id:1},{id:2}]\r\n */\r\nfunction uniqueArray(src, key, sort) {\r\n    var results = [];\r\n    var values = [];\r\n    var i = 0;\r\n\r\n    while (i < src.length) {\r\n        var val = key ? src[i][key] : src[i];\r\n        if (inArray(values, val) < 0) {\r\n            results.push(src[i]);\r\n        }\r\n        values[i] = val;\r\n        i++;\r\n    }\r\n\r\n    if (sort) {\r\n        if (!key) {\r\n            results = results.sort();\r\n        } else {\r\n            results = results.sort(function sortUniqueArray(a, b) {\r\n                return a[key] > b[key];\r\n            });\r\n        }\r\n    }\r\n\r\n    return results;\r\n}\r\n\r\n/**\r\n * get the prefixed property\r\n * @param {Object} obj\r\n * @param {String} property\r\n * @returns {String|Undefined} prefixed\r\n */\r\nfunction prefixed(obj, property) {\r\n    var prefix, prop;\r\n    var camelProp = property[0].toUpperCase() + property.slice(1);\r\n\r\n    var i = 0;\r\n    while (i < VENDOR_PREFIXES.length) {\r\n        prefix = VENDOR_PREFIXES[i];\r\n        prop = (prefix) ? prefix + camelProp : property;\r\n\r\n        if (prop in obj) {\r\n            return prop;\r\n        }\r\n        i++;\r\n    }\r\n    return undefined;\r\n}\r\n\r\n/**\r\n * get a unique id\r\n * @returns {number} uniqueId\r\n */\r\nvar _uniqueId = 1;\r\nfunction uniqueId() {\r\n    return _uniqueId++;\r\n}\r\n\r\n/**\r\n * get the window object of an element\r\n * @param {HTMLElement} element\r\n * @returns {DocumentView|Window}\r\n */\r\nfunction getWindowForElement(element) {\r\n    var doc = element.ownerDocument;\r\n    return (doc.defaultView || doc.parentWindow);\r\n}\r\n\r\nvar MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\r\n\r\nvar SUPPORT_TOUCH = ('ontouchstart' in window);\r\nvar SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\r\nvar SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\r\n\r\nvar INPUT_TYPE_TOUCH = 'touch';\r\nvar INPUT_TYPE_PEN = 'pen';\r\nvar INPUT_TYPE_MOUSE = 'mouse';\r\nvar INPUT_TYPE_KINECT = 'kinect';\r\n\r\nvar COMPUTE_INTERVAL = 25;\r\n\r\nvar INPUT_START = 1;\r\nvar INPUT_MOVE = 2;\r\nvar INPUT_END = 4;\r\nvar INPUT_CANCEL = 8;\r\n\r\nvar DIRECTION_NONE = 1;\r\nvar DIRECTION_LEFT = 2;\r\nvar DIRECTION_RIGHT = 4;\r\nvar DIRECTION_UP = 8;\r\nvar DIRECTION_DOWN = 16;\r\n\r\nvar DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\r\nvar DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\r\nvar DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\r\n\r\nvar PROPS_XY = ['x', 'y'];\r\nvar PROPS_CLIENT_XY = ['clientX', 'clientY'];\r\n\r\n/**\r\n * create new input type manager\r\n * @param {Manager} manager\r\n * @param {Function} callback\r\n * @returns {Input}\r\n * @constructor\r\n */\r\nfunction Input(manager, callback) {\r\n    var self = this;\r\n    this.manager = manager;\r\n    this.callback = callback;\r\n    this.element = manager.element;\r\n    this.target = manager.options.inputTarget;\r\n\r\n    // smaller wrapper around the handler, for the scope and the enabled state of the manager,\r\n    // so when disabled the input events are completely bypassed.\r\n    this.domHandler = function(ev) {\r\n        if (boolOrFn(manager.options.enable, [manager])) {\r\n            self.handler(ev);\r\n        }\r\n    };\r\n\r\n    this.init();\r\n\r\n}\r\n\r\nInput.prototype = {\r\n    /**\r\n     * should handle the inputEvent data and trigger the callback\r\n     * @virtual\r\n     */\r\n    handler: function() { },\r\n\r\n    /**\r\n     * bind the events\r\n     */\r\n    init: function() {\r\n        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\r\n        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\r\n        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\r\n    },\r\n\r\n    /**\r\n     * unbind the events\r\n     */\r\n    destroy: function() {\r\n        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\r\n        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\r\n        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\r\n    }\r\n};\r\n\r\n/**\r\n * create new input type manager\r\n * called by the Manager constructor\r\n * @param {Hammer} manager\r\n * @returns {Input}\r\n */\r\nfunction createInputInstance(manager) {\r\n    var Type;\r\n    var inputClass = manager.options.inputClass;\r\n\r\n    if (inputClass) {\r\n        Type = inputClass;\r\n    } else if (SUPPORT_POINTER_EVENTS) {\r\n        Type = PointerEventInput;\r\n    } else if (SUPPORT_ONLY_TOUCH) {\r\n        Type = TouchInput;\r\n    } else if (!SUPPORT_TOUCH) {\r\n        Type = MouseInput;\r\n    } else {\r\n        Type = TouchMouseInput;\r\n    }\r\n    return new (Type)(manager, inputHandler);\r\n}\r\n\r\n/**\r\n * handle input events\r\n * @param {Manager} manager\r\n * @param {String} eventType\r\n * @param {Object} input\r\n */\r\nfunction inputHandler(manager, eventType, input) {\r\n    var pointersLen = input.pointers.length;\r\n    var changedPointersLen = input.changedPointers.length;\r\n    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));\r\n    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));\r\n\r\n    input.isFirst = !!isFirst;\r\n    input.isFinal = !!isFinal;\r\n\r\n    if (isFirst) {\r\n        manager.session = {};\r\n    }\r\n\r\n    // source event is the normalized value of the domEvents\r\n    // like 'touchstart, mouseup, pointerdown'\r\n    input.eventType = eventType;\r\n\r\n    // compute scale, rotation etc\r\n    computeInputData(manager, input);\r\n\r\n    // emit secret event\r\n    manager.emit('hammer.input', input);\r\n\r\n    manager.recognize(input);\r\n    manager.session.prevInput = input;\r\n}\r\n\r\n/**\r\n * extend the data with some usable properties like scale, rotate, velocity etc\r\n * @param {Object} manager\r\n * @param {Object} input\r\n */\r\nfunction computeInputData(manager, input) {\r\n    var session = manager.session;\r\n    var pointers = input.pointers;\r\n    var pointersLength = pointers.length;\r\n\r\n    // store the first input to calculate the distance and direction\r\n    if (!session.firstInput) {\r\n        session.firstInput = simpleCloneInputData(input);\r\n    }\r\n\r\n    // to compute scale and rotation we need to store the multiple touches\r\n    if (pointersLength > 1 && !session.firstMultiple) {\r\n        session.firstMultiple = simpleCloneInputData(input);\r\n    } else if (pointersLength === 1) {\r\n        session.firstMultiple = false;\r\n    }\r\n\r\n    var firstInput = session.firstInput;\r\n    var firstMultiple = session.firstMultiple;\r\n    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\r\n\r\n    var center = input.center = getCenter(pointers);\r\n    input.timeStamp = now();\r\n    input.deltaTime = input.timeStamp - firstInput.timeStamp;\r\n\r\n    input.angle = getAngle(offsetCenter, center);\r\n    input.distance = getDistance(offsetCenter, center);\r\n\r\n    computeDeltaXY(session, input);\r\n    input.offsetDirection = getDirection(input.deltaX, input.deltaY);\r\n\r\n    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\r\n    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\r\n\r\n    computeIntervalInputData(session, input);\r\n\r\n    // find the correct target\r\n    var target = manager.element;\r\n    if (hasParent(input.srcEvent.target, target)) {\r\n        target = input.srcEvent.target;\r\n    }\r\n    input.target = target;\r\n}\r\n\r\nfunction computeDeltaXY(session, input) {\r\n    var center = input.center;\r\n    var offset = session.offsetDelta || {};\r\n    var prevDelta = session.prevDelta || {};\r\n    var prevInput = session.prevInput || {};\r\n\r\n    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\r\n        prevDelta = session.prevDelta = {\r\n            x: prevInput.deltaX || 0,\r\n            y: prevInput.deltaY || 0\r\n        };\r\n\r\n        offset = session.offsetDelta = {\r\n            x: center.x,\r\n            y: center.y\r\n        };\r\n    }\r\n\r\n    input.deltaX = prevDelta.x + (center.x - offset.x);\r\n    input.deltaY = prevDelta.y + (center.y - offset.y);\r\n}\r\n\r\n/**\r\n * velocity is calculated every x ms\r\n * @param {Object} session\r\n * @param {Object} input\r\n */\r\nfunction computeIntervalInputData(session, input) {\r\n    var last = session.lastInterval || input,\r\n        deltaTime = input.timeStamp - last.timeStamp,\r\n        velocity, velocityX, velocityY, direction;\r\n\r\n    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\r\n        var deltaX = last.deltaX - input.deltaX;\r\n        var deltaY = last.deltaY - input.deltaY;\r\n\r\n        var v = getVelocity(deltaTime, deltaX, deltaY);\r\n        velocityX = v.x;\r\n        velocityY = v.y;\r\n        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;\r\n        direction = getDirection(deltaX, deltaY);\r\n\r\n        session.lastInterval = input;\r\n    } else {\r\n        // use latest velocity info if it doesn't overtake a minimum period\r\n        velocity = last.velocity;\r\n        velocityX = last.velocityX;\r\n        velocityY = last.velocityY;\r\n        direction = last.direction;\r\n    }\r\n\r\n    input.velocity = velocity;\r\n    input.velocityX = velocityX;\r\n    input.velocityY = velocityY;\r\n    input.direction = direction;\r\n}\r\n\r\n/**\r\n * create a simple clone from the input used for storage of firstInput and firstMultiple\r\n * @param {Object} input\r\n * @returns {Object} clonedInputData\r\n */\r\nfunction simpleCloneInputData(input) {\r\n    // make a simple copy of the pointers because we will get a reference if we don't\r\n    // we only need clientXY for the calculations\r\n    var pointers = [];\r\n    var i = 0;\r\n    while (i < input.pointers.length) {\r\n        pointers[i] = {\r\n            clientX: round(input.pointers[i].clientX),\r\n            clientY: round(input.pointers[i].clientY)\r\n        };\r\n        i++;\r\n    }\r\n\r\n    return {\r\n        timeStamp: now(),\r\n        pointers: pointers,\r\n        center: getCenter(pointers),\r\n        deltaX: input.deltaX,\r\n        deltaY: input.deltaY\r\n    };\r\n}\r\n\r\n/**\r\n * get the center of all the pointers\r\n * @param {Array} pointers\r\n * @return {Object} center contains `x` and `y` properties\r\n */\r\nfunction getCenter(pointers) {\r\n    var pointersLength = pointers.length;\r\n\r\n    // no need to loop when only one touch\r\n    if (pointersLength === 1) {\r\n        return {\r\n            x: round(pointers[0].clientX),\r\n            y: round(pointers[0].clientY)\r\n        };\r\n    }\r\n\r\n    var x = 0, y = 0, i = 0;\r\n    while (i < pointersLength) {\r\n        x += pointers[i].clientX;\r\n        y += pointers[i].clientY;\r\n        i++;\r\n    }\r\n\r\n    return {\r\n        x: round(x / pointersLength),\r\n        y: round(y / pointersLength)\r\n    };\r\n}\r\n\r\n/**\r\n * calculate the velocity between two points. unit is in px per ms.\r\n * @param {Number} deltaTime\r\n * @param {Number} x\r\n * @param {Number} y\r\n * @return {Object} velocity `x` and `y`\r\n */\r\nfunction getVelocity(deltaTime, x, y) {\r\n    return {\r\n        x: x / deltaTime || 0,\r\n        y: y / deltaTime || 0\r\n    };\r\n}\r\n\r\n/**\r\n * get the direction between two points\r\n * @param {Number} x\r\n * @param {Number} y\r\n * @return {Number} direction\r\n */\r\nfunction getDirection(x, y) {\r\n    if (x === y) {\r\n        return DIRECTION_NONE;\r\n    }\r\n\r\n    if (abs(x) >= abs(y)) {\r\n        return x > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\r\n    }\r\n    return y > 0 ? DIRECTION_UP : DIRECTION_DOWN;\r\n}\r\n\r\n/**\r\n * calculate the absolute distance between two points\r\n * @param {Object} p1 {x, y}\r\n * @param {Object} p2 {x, y}\r\n * @param {Array} [props] containing x and y keys\r\n * @return {Number} distance\r\n */\r\nfunction getDistance(p1, p2, props) {\r\n    if (!props) {\r\n        props = PROPS_XY;\r\n    }\r\n    var x = p2[props[0]] - p1[props[0]],\r\n        y = p2[props[1]] - p1[props[1]];\r\n\r\n    return Math.sqrt((x * x) + (y * y));\r\n}\r\n\r\n/**\r\n * calculate the angle between two coordinates\r\n * @param {Object} p1\r\n * @param {Object} p2\r\n * @param {Array} [props] containing x and y keys\r\n * @return {Number} angle\r\n */\r\nfunction getAngle(p1, p2, props) {\r\n    if (!props) {\r\n        props = PROPS_XY;\r\n    }\r\n    var x = p2[props[0]] - p1[props[0]],\r\n        y = p2[props[1]] - p1[props[1]];\r\n    return Math.atan2(y, x) * 180 / Math.PI;\r\n}\r\n\r\n/**\r\n * calculate the rotation degrees between two pointersets\r\n * @param {Array} start array of pointers\r\n * @param {Array} end array of pointers\r\n * @return {Number} rotation\r\n */\r\nfunction getRotation(start, end) {\r\n    return getAngle(end[1], end[0], PROPS_CLIENT_XY) - getAngle(start[1], start[0], PROPS_CLIENT_XY);\r\n}\r\n\r\n/**\r\n * calculate the scale factor between two pointersets\r\n * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\r\n * @param {Array} start array of pointers\r\n * @param {Array} end array of pointers\r\n * @return {Number} scale\r\n */\r\nfunction getScale(start, end) {\r\n    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\r\n}\r\n\r\nvar MOUSE_INPUT_MAP = {\r\n    mousedown: INPUT_START,\r\n    mousemove: INPUT_MOVE,\r\n    mouseup: INPUT_END\r\n};\r\n\r\nvar MOUSE_ELEMENT_EVENTS = 'mousedown';\r\nvar MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\r\n\r\n/**\r\n * Mouse events input\r\n * @constructor\r\n * @extends Input\r\n */\r\nfunction MouseInput() {\r\n    this.evEl = MOUSE_ELEMENT_EVENTS;\r\n    this.evWin = MOUSE_WINDOW_EVENTS;\r\n\r\n    this.allow = true; // used by Input.TouchMouse to disable mouse events\r\n    this.pressed = false; // mousedown state\r\n\r\n    Input.apply(this, arguments);\r\n}\r\n\r\ninherit(MouseInput, Input, {\r\n    /**\r\n     * handle mouse events\r\n     * @param {Object} ev\r\n     */\r\n    handler: function MEhandler(ev) {\r\n        var eventType = MOUSE_INPUT_MAP[ev.type];\r\n\r\n        // on start we want to have the left mouse button down\r\n        if (eventType & INPUT_START && ev.button === 0) {\r\n            this.pressed = true;\r\n        }\r\n\r\n        if (eventType & INPUT_MOVE && ev.which !== 1) {\r\n            eventType = INPUT_END;\r\n        }\r\n\r\n        // mouse must be down, and mouse events are allowed (see the TouchMouse input)\r\n        if (!this.pressed || !this.allow) {\r\n            return;\r\n        }\r\n\r\n        if (eventType & INPUT_END) {\r\n            this.pressed = false;\r\n        }\r\n\r\n        this.callback(this.manager, eventType, {\r\n            pointers: [ev],\r\n            changedPointers: [ev],\r\n            pointerType: INPUT_TYPE_MOUSE,\r\n            srcEvent: ev\r\n        });\r\n    }\r\n});\r\n\r\nvar POINTER_INPUT_MAP = {\r\n    pointerdown: INPUT_START,\r\n    pointermove: INPUT_MOVE,\r\n    pointerup: INPUT_END,\r\n    pointercancel: INPUT_CANCEL,\r\n    pointerout: INPUT_CANCEL\r\n};\r\n\r\n// in IE10 the pointer types is defined as an enum\r\nvar IE10_POINTER_TYPE_ENUM = {\r\n    2: INPUT_TYPE_TOUCH,\r\n    3: INPUT_TYPE_PEN,\r\n    4: INPUT_TYPE_MOUSE,\r\n    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\r\n};\r\n\r\nvar POINTER_ELEMENT_EVENTS = 'pointerdown';\r\nvar POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';\r\n\r\n// IE10 has prefixed support, and case-sensitive\r\nif (window.MSPointerEvent) {\r\n    POINTER_ELEMENT_EVENTS = 'MSPointerDown';\r\n    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\r\n}\r\n\r\n/**\r\n * Pointer events input\r\n * @constructor\r\n * @extends Input\r\n */\r\nfunction PointerEventInput() {\r\n    this.evEl = POINTER_ELEMENT_EVENTS;\r\n    this.evWin = POINTER_WINDOW_EVENTS;\r\n\r\n    Input.apply(this, arguments);\r\n\r\n    this.store = (this.manager.session.pointerEvents = []);\r\n}\r\n\r\ninherit(PointerEventInput, Input, {\r\n    /**\r\n     * handle mouse events\r\n     * @param {Object} ev\r\n     */\r\n    handler: function PEhandler(ev) {\r\n        var store = this.store;\r\n        var removePointer = false;\r\n\r\n        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\r\n        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\r\n        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\r\n\r\n        var isTouch = (pointerType == INPUT_TYPE_TOUCH);\r\n\r\n        // get index of the event in the store\r\n        var storeIndex = inArray(store, ev.pointerId, 'pointerId');\r\n\r\n        // start and mouse must be down\r\n        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\r\n            if (storeIndex < 0) {\r\n                store.push(ev);\r\n                storeIndex = store.length - 1;\r\n            }\r\n        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\r\n            removePointer = true;\r\n        }\r\n\r\n        // it not found, so the pointer hasn't been down (so it's probably a hover)\r\n        if (storeIndex < 0) {\r\n            return;\r\n        }\r\n\r\n        // update the event in the store\r\n        store[storeIndex] = ev;\r\n\r\n        this.callback(this.manager, eventType, {\r\n            pointers: store,\r\n            changedPointers: [ev],\r\n            pointerType: pointerType,\r\n            srcEvent: ev\r\n        });\r\n\r\n        if (removePointer) {\r\n            // remove from the store\r\n            store.splice(storeIndex, 1);\r\n        }\r\n    }\r\n});\r\n\r\nvar SINGLE_TOUCH_INPUT_MAP = {\r\n    touchstart: INPUT_START,\r\n    touchmove: INPUT_MOVE,\r\n    touchend: INPUT_END,\r\n    touchcancel: INPUT_CANCEL\r\n};\r\n\r\nvar SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\r\nvar SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\r\n\r\n/**\r\n * Touch events input\r\n * @constructor\r\n * @extends Input\r\n */\r\nfunction SingleTouchInput() {\r\n    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\r\n    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\r\n    this.started = false;\r\n\r\n    Input.apply(this, arguments);\r\n}\r\n\r\ninherit(SingleTouchInput, Input, {\r\n    handler: function TEhandler(ev) {\r\n        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];\r\n\r\n        // should we handle the touch events?\r\n        if (type === INPUT_START) {\r\n            this.started = true;\r\n        }\r\n\r\n        if (!this.started) {\r\n            return;\r\n        }\r\n\r\n        var touches = normalizeSingleTouches.call(this, ev, type);\r\n\r\n        // when done, reset the started state\r\n        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\r\n            this.started = false;\r\n        }\r\n\r\n        this.callback(this.manager, type, {\r\n            pointers: touches[0],\r\n            changedPointers: touches[1],\r\n            pointerType: INPUT_TYPE_TOUCH,\r\n            srcEvent: ev\r\n        });\r\n    }\r\n});\r\n\r\n/**\r\n * @this {TouchInput}\r\n * @param {Object} ev\r\n * @param {Number} type flag\r\n * @returns {undefined|Array} [all, changed]\r\n */\r\nfunction normalizeSingleTouches(ev, type) {\r\n    var all = toArray(ev.touches);\r\n    var changed = toArray(ev.changedTouches);\r\n\r\n    if (type & (INPUT_END | INPUT_CANCEL)) {\r\n        all = uniqueArray(all.concat(changed), 'identifier', true);\r\n    }\r\n\r\n    return [all, changed];\r\n}\r\n\r\nvar TOUCH_INPUT_MAP = {\r\n    touchstart: INPUT_START,\r\n    touchmove: INPUT_MOVE,\r\n    touchend: INPUT_END,\r\n    touchcancel: INPUT_CANCEL\r\n};\r\n\r\nvar TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\r\n\r\n/**\r\n * Multi-user touch events input\r\n * @constructor\r\n * @extends Input\r\n */\r\nfunction TouchInput() {\r\n    this.evTarget = TOUCH_TARGET_EVENTS;\r\n    this.targetIds = {};\r\n\r\n    Input.apply(this, arguments);\r\n}\r\n\r\ninherit(TouchInput, Input, {\r\n    handler: function MTEhandler(ev) {\r\n        var type = TOUCH_INPUT_MAP[ev.type];\r\n        var touches = getTouches.call(this, ev, type);\r\n        if (!touches) {\r\n            return;\r\n        }\r\n\r\n        this.callback(this.manager, type, {\r\n            pointers: touches[0],\r\n            changedPointers: touches[1],\r\n            pointerType: INPUT_TYPE_TOUCH,\r\n            srcEvent: ev\r\n        });\r\n    }\r\n});\r\n\r\n/**\r\n * @this {TouchInput}\r\n * @param {Object} ev\r\n * @param {Number} type flag\r\n * @returns {undefined|Array} [all, changed]\r\n */\r\nfunction getTouches(ev, type) {\r\n    var allTouches = toArray(ev.touches);\r\n    var targetIds = this.targetIds;\r\n\r\n    // when there is only one touch, the process can be simplified\r\n    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\r\n        targetIds[allTouches[0].identifier] = true;\r\n        return [allTouches, allTouches];\r\n    }\r\n\r\n    var i,\r\n        targetTouches,\r\n        changedTouches = toArray(ev.changedTouches),\r\n        changedTargetTouches = [],\r\n        target = this.target;\r\n\r\n    // get target touches from touches\r\n    targetTouches = allTouches.filter(function(touch) {\r\n        return hasParent(touch.target, target);\r\n    });\r\n\r\n    // collect touches\r\n    if (type === INPUT_START) {\r\n        i = 0;\r\n        while (i < targetTouches.length) {\r\n            targetIds[targetTouches[i].identifier] = true;\r\n            i++;\r\n        }\r\n    }\r\n\r\n    // filter changed touches to only contain touches that exist in the collected target ids\r\n    i = 0;\r\n    while (i < changedTouches.length) {\r\n        if (targetIds[changedTouches[i].identifier]) {\r\n            changedTargetTouches.push(changedTouches[i]);\r\n        }\r\n\r\n        // cleanup removed touches\r\n        if (type & (INPUT_END | INPUT_CANCEL)) {\r\n            delete targetIds[changedTouches[i].identifier];\r\n        }\r\n        i++;\r\n    }\r\n\r\n    if (!changedTargetTouches.length) {\r\n        return;\r\n    }\r\n\r\n    return [\r\n        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\r\n        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),\r\n        changedTargetTouches\r\n    ];\r\n}\r\n\r\n/**\r\n * Combined touch and mouse input\r\n *\r\n * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\r\n * This because touch devices also emit mouse events while doing a touch.\r\n *\r\n * @constructor\r\n * @extends Input\r\n */\r\nfunction TouchMouseInput() {\r\n    Input.apply(this, arguments);\r\n\r\n    var handler = bindFn(this.handler, this);\r\n    this.touch = new TouchInput(this.manager, handler);\r\n    this.mouse = new MouseInput(this.manager, handler);\r\n}\r\n\r\ninherit(TouchMouseInput, Input, {\r\n    /**\r\n     * handle mouse and touch events\r\n     * @param {Hammer} manager\r\n     * @param {String} inputEvent\r\n     * @param {Object} inputData\r\n     */\r\n    handler: function TMEhandler(manager, inputEvent, inputData) {\r\n        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),\r\n            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);\r\n\r\n        // when we're in a touch event, so  block all upcoming mouse events\r\n        // most mobile browser also emit mouseevents, right after touchstart\r\n        if (isTouch) {\r\n            this.mouse.allow = false;\r\n        } else if (isMouse && !this.mouse.allow) {\r\n            return;\r\n        }\r\n\r\n        // reset the allowMouse when we're done\r\n        if (inputEvent & (INPUT_END | INPUT_CANCEL)) {\r\n            this.mouse.allow = true;\r\n        }\r\n\r\n        this.callback(manager, inputEvent, inputData);\r\n    },\r\n\r\n    /**\r\n     * remove the event listeners\r\n     */\r\n    destroy: function destroy() {\r\n        this.touch.destroy();\r\n        this.mouse.destroy();\r\n    }\r\n});\r\n\r\nvar PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\r\nvar NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\r\n\r\n// magical touchAction value\r\nvar TOUCH_ACTION_COMPUTE = 'compute';\r\nvar TOUCH_ACTION_AUTO = 'auto';\r\nvar TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\r\nvar TOUCH_ACTION_NONE = 'none';\r\nvar TOUCH_ACTION_PAN_X = 'pan-x';\r\nvar TOUCH_ACTION_PAN_Y = 'pan-y';\r\n\r\n/**\r\n * Touch Action\r\n * sets the touchAction property or uses the js alternative\r\n * @param {Manager} manager\r\n * @param {String} value\r\n * @constructor\r\n */\r\nfunction TouchAction(manager, value) {\r\n    this.manager = manager;\r\n    this.set(value);\r\n}\r\n\r\nTouchAction.prototype = {\r\n    /**\r\n     * set the touchAction value on the element or enable the polyfill\r\n     * @param {String} value\r\n     */\r\n    set: function(value) {\r\n        // find out the touch-action by the event handlers\r\n        if (value == TOUCH_ACTION_COMPUTE) {\r\n            value = this.compute();\r\n        }\r\n\r\n        if (NATIVE_TOUCH_ACTION) {\r\n            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\r\n        }\r\n        this.actions = value.toLowerCase().trim();\r\n    },\r\n\r\n    /**\r\n     * just re-set the touchAction value\r\n     */\r\n    update: function() {\r\n        this.set(this.manager.options.touchAction);\r\n    },\r\n\r\n    /**\r\n     * compute the value for the touchAction property based on the recognizer's settings\r\n     * @returns {String} value\r\n     */\r\n    compute: function() {\r\n        var actions = [];\r\n        each(this.manager.recognizers, function(recognizer) {\r\n            if (boolOrFn(recognizer.options.enable, [recognizer])) {\r\n                actions = actions.concat(recognizer.getTouchAction());\r\n            }\r\n        });\r\n        return cleanTouchActions(actions.join(' '));\r\n    },\r\n\r\n    /**\r\n     * this method is called on each input cycle and provides the preventing of the browser behavior\r\n     * @param {Object} input\r\n     */\r\n    preventDefaults: function(input) {\r\n        // not needed with native support for the touchAction property\r\n        if (NATIVE_TOUCH_ACTION) {\r\n            return;\r\n        }\r\n\r\n        var srcEvent = input.srcEvent;\r\n        var direction = input.offsetDirection;\r\n\r\n        // if the touch action did prevented once this session\r\n        if (this.manager.session.prevented) {\r\n            srcEvent.preventDefault();\r\n            return;\r\n        }\r\n\r\n        var actions = this.actions;\r\n        var hasNone = inStr(actions, TOUCH_ACTION_NONE);\r\n        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\r\n        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\r\n\r\n        if (hasNone ||\r\n            (hasPanY && direction & DIRECTION_HORIZONTAL) ||\r\n            (hasPanX && direction & DIRECTION_VERTICAL)) {\r\n            return this.preventSrc(srcEvent);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\r\n     * @param {Object} srcEvent\r\n     */\r\n    preventSrc: function(srcEvent) {\r\n        this.manager.session.prevented = true;\r\n        srcEvent.preventDefault();\r\n    }\r\n};\r\n\r\n/**\r\n * when the touchActions are collected they are not a valid value, so we need to clean things up. *\r\n * @param {String} actions\r\n * @returns {*}\r\n */\r\nfunction cleanTouchActions(actions) {\r\n    // none\r\n    if (inStr(actions, TOUCH_ACTION_NONE)) {\r\n        return TOUCH_ACTION_NONE;\r\n    }\r\n\r\n    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\r\n    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\r\n\r\n    // pan-x and pan-y can be combined\r\n    if (hasPanX && hasPanY) {\r\n        return TOUCH_ACTION_PAN_X + ' ' + TOUCH_ACTION_PAN_Y;\r\n    }\r\n\r\n    // pan-x OR pan-y\r\n    if (hasPanX || hasPanY) {\r\n        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\r\n    }\r\n\r\n    // manipulation\r\n    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\r\n        return TOUCH_ACTION_MANIPULATION;\r\n    }\r\n\r\n    return TOUCH_ACTION_AUTO;\r\n}\r\n\r\n/**\r\n * Recognizer flow explained; *\r\n * All recognizers have the initial state of POSSIBLE when a input session starts.\r\n * The definition of a input session is from the first input until the last input, with all it's movement in it. *\r\n * Example session for mouse-input: mousedown -> mousemove -> mouseup\r\n *\r\n * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\r\n * which determines with state it should be.\r\n *\r\n * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\r\n * POSSIBLE to give it another change on the next cycle.\r\n *\r\n *               Possible\r\n *                  |\r\n *            +-----+---------------+\r\n *            |                     |\r\n *      +-----+-----+               |\r\n *      |           |               |\r\n *   Failed      Cancelled          |\r\n *                          +-------+------+\r\n *                          |              |\r\n *                      Recognized       Began\r\n *                                         |\r\n *                                      Changed\r\n *                                         |\r\n *                                  Ended/Recognized\r\n */\r\nvar STATE_POSSIBLE = 1;\r\nvar STATE_BEGAN = 2;\r\nvar STATE_CHANGED = 4;\r\nvar STATE_ENDED = 8;\r\nvar STATE_RECOGNIZED = STATE_ENDED;\r\nvar STATE_CANCELLED = 16;\r\nvar STATE_FAILED = 32;\r\n\r\n/**\r\n * Recognizer\r\n * Every recognizer needs to extend from this class.\r\n * @constructor\r\n * @param {Object} options\r\n */\r\nfunction Recognizer(options) {\r\n    this.id = uniqueId();\r\n\r\n    this.manager = null;\r\n    this.options = merge(options || {}, this.defaults);\r\n\r\n    // default is enable true\r\n    this.options.enable = ifUndefined(this.options.enable, true);\r\n\r\n    this.state = STATE_POSSIBLE;\r\n\r\n    this.simultaneous = {};\r\n    this.requireFail = [];\r\n}\r\n\r\nRecognizer.prototype = {\r\n    /**\r\n     * @virtual\r\n     * @type {Object}\r\n     */\r\n    defaults: {},\r\n\r\n    /**\r\n     * set options\r\n     * @param {Object} options\r\n     * @return {Recognizer}\r\n     */\r\n    set: function(options) {\r\n        extend(this.options, options);\r\n\r\n        // also update the touchAction, in case something changed about the directions/enabled state\r\n        this.manager && this.manager.touchAction.update();\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * recognize simultaneous with an other recognizer.\r\n     * @param {Recognizer} otherRecognizer\r\n     * @returns {Recognizer} this\r\n     */\r\n    recognizeWith: function(otherRecognizer) {\r\n        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\r\n            return this;\r\n        }\r\n\r\n        var simultaneous = this.simultaneous;\r\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\r\n        if (!simultaneous[otherRecognizer.id]) {\r\n            simultaneous[otherRecognizer.id] = otherRecognizer;\r\n            otherRecognizer.recognizeWith(this);\r\n        }\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * drop the simultaneous link. it doesnt remove the link on the other recognizer.\r\n     * @param {Recognizer} otherRecognizer\r\n     * @returns {Recognizer} this\r\n     */\r\n    dropRecognizeWith: function(otherRecognizer) {\r\n        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\r\n            return this;\r\n        }\r\n\r\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\r\n        delete this.simultaneous[otherRecognizer.id];\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * recognizer can only run when an other is failing\r\n     * @param {Recognizer} otherRecognizer\r\n     * @returns {Recognizer} this\r\n     */\r\n    requireFailure: function(otherRecognizer) {\r\n        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\r\n            return this;\r\n        }\r\n\r\n        var requireFail = this.requireFail;\r\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\r\n        if (inArray(requireFail, otherRecognizer) === -1) {\r\n            requireFail.push(otherRecognizer);\r\n            otherRecognizer.requireFailure(this);\r\n        }\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * drop the requireFailure link. it does not remove the link on the other recognizer.\r\n     * @param {Recognizer} otherRecognizer\r\n     * @returns {Recognizer} this\r\n     */\r\n    dropRequireFailure: function(otherRecognizer) {\r\n        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\r\n            return this;\r\n        }\r\n\r\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\r\n        var index = inArray(this.requireFail, otherRecognizer);\r\n        if (index > -1) {\r\n            this.requireFail.splice(index, 1);\r\n        }\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * has require failures boolean\r\n     * @returns {boolean}\r\n     */\r\n    hasRequireFailures: function() {\r\n        return this.requireFail.length > 0;\r\n    },\r\n\r\n    /**\r\n     * if the recognizer can recognize simultaneous with an other recognizer\r\n     * @param {Recognizer} otherRecognizer\r\n     * @returns {Boolean}\r\n     */\r\n    canRecognizeWith: function(otherRecognizer) {\r\n        return !!this.simultaneous[otherRecognizer.id];\r\n    },\r\n\r\n    /**\r\n     * You should use `tryEmit` instead of `emit` directly to check\r\n     * that all the needed recognizers has failed before emitting.\r\n     * @param {Object} input\r\n     */\r\n    emit: function(input) {\r\n        var self = this;\r\n        var state = this.state;\r\n\r\n        function emit(withState) {\r\n            self.manager.emit(self.options.event + (withState ? stateStr(state) : ''), input);\r\n        }\r\n\r\n        // 'panstart' and 'panmove'\r\n        if (state < STATE_ENDED) {\r\n            emit(true);\r\n        }\r\n\r\n        emit(); // simple 'eventName' events\r\n\r\n        // panend and pancancel\r\n        if (state >= STATE_ENDED) {\r\n            emit(true);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Check that all the require failure recognizers has failed,\r\n     * if true, it emits a gesture event,\r\n     * otherwise, setup the state to FAILED.\r\n     * @param {Object} input\r\n     */\r\n    tryEmit: function(input) {\r\n        if (this.canEmit()) {\r\n            return this.emit(input);\r\n        }\r\n        // it's failing anyway\r\n        this.state = STATE_FAILED;\r\n    },\r\n\r\n    /**\r\n     * can we emit?\r\n     * @returns {boolean}\r\n     */\r\n    canEmit: function() {\r\n        var i = 0;\r\n        while (i < this.requireFail.length) {\r\n            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\r\n                return false;\r\n            }\r\n            i++;\r\n        }\r\n        return true;\r\n    },\r\n\r\n    /**\r\n     * update the recognizer\r\n     * @param {Object} inputData\r\n     */\r\n    recognize: function(inputData) {\r\n        // make a new copy of the inputData\r\n        // so we can change the inputData without messing up the other recognizers\r\n        var inputDataClone = extend({}, inputData);\r\n\r\n        // is is enabled and allow recognizing?\r\n        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\r\n            this.reset();\r\n            this.state = STATE_FAILED;\r\n            return;\r\n        }\r\n\r\n        // reset when we've reached the end\r\n        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\r\n            this.state = STATE_POSSIBLE;\r\n        }\r\n\r\n        this.state = this.process(inputDataClone);\r\n\r\n        // the recognizer has recognized a gesture\r\n        // so trigger an event\r\n        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\r\n            this.tryEmit(inputDataClone);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * return the state of the recognizer\r\n     * the actual recognizing happens in this method\r\n     * @virtual\r\n     * @param {Object} inputData\r\n     * @returns {Const} STATE\r\n     */\r\n    process: function(inputData) { }, // jshint ignore:line\r\n\r\n    /**\r\n     * return the preferred touch-action\r\n     * @virtual\r\n     * @returns {Array}\r\n     */\r\n    getTouchAction: function() { },\r\n\r\n    /**\r\n     * called when the gesture isn't allowed to recognize\r\n     * like when another is being recognized or it is disabled\r\n     * @virtual\r\n     */\r\n    reset: function() { }\r\n};\r\n\r\n/**\r\n * get a usable string, used as event postfix\r\n * @param {Const} state\r\n * @returns {String} state\r\n */\r\nfunction stateStr(state) {\r\n    if (state & STATE_CANCELLED) {\r\n        return 'cancel';\r\n    } else if (state & STATE_ENDED) {\r\n        return 'end';\r\n    } else if (state & STATE_CHANGED) {\r\n        return 'move';\r\n    } else if (state & STATE_BEGAN) {\r\n        return 'start';\r\n    }\r\n    return '';\r\n}\r\n\r\n/**\r\n * direction cons to string\r\n * @param {Const} direction\r\n * @returns {String}\r\n */\r\nfunction directionStr(direction) {\r\n    if (direction == DIRECTION_DOWN) {\r\n        return 'down';\r\n    } else if (direction == DIRECTION_UP) {\r\n        return 'up';\r\n    } else if (direction == DIRECTION_LEFT) {\r\n        return 'left';\r\n    } else if (direction == DIRECTION_RIGHT) {\r\n        return 'right';\r\n    }\r\n    return '';\r\n}\r\n\r\n/**\r\n * get a recognizer by name if it is bound to a manager\r\n * @param {Recognizer|String} otherRecognizer\r\n * @param {Recognizer} recognizer\r\n * @returns {Recognizer}\r\n */\r\nfunction getRecognizerByNameIfManager(otherRecognizer, recognizer) {\r\n    var manager = recognizer.manager;\r\n    if (manager) {\r\n        return manager.get(otherRecognizer);\r\n    }\r\n    return otherRecognizer;\r\n}\r\n\r\n/**\r\n * This recognizer is just used as a base for the simple attribute recognizers.\r\n * @constructor\r\n * @extends Recognizer\r\n */\r\nfunction AttrRecognizer() {\r\n    Recognizer.apply(this, arguments);\r\n}\r\n\r\ninherit(AttrRecognizer, Recognizer, {\r\n    /**\r\n     * @namespace\r\n     * @memberof AttrRecognizer\r\n     */\r\n    defaults: {\r\n        /**\r\n         * @type {Number}\r\n         * @default 1\r\n         */\r\n        pointers: 1\r\n    },\r\n\r\n    /**\r\n     * Used to check if it the recognizer receives valid input, like input.distance > 10.\r\n     * @memberof AttrRecognizer\r\n     * @param {Object} input\r\n     * @returns {Boolean} recognized\r\n     */\r\n    attrTest: function(input) {\r\n        var optionPointers = this.options.pointers;\r\n        return optionPointers === 0 || input.pointers.length === optionPointers;\r\n    },\r\n\r\n    /**\r\n     * Process the input and return the state for the recognizer\r\n     * @memberof AttrRecognizer\r\n     * @param {Object} input\r\n     * @returns {*} State\r\n     */\r\n    process: function(input) {\r\n        var state = this.state;\r\n        var eventType = input.eventType;\r\n\r\n        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\r\n        var isValid = this.attrTest(input);\r\n\r\n        // on cancel input and we've recognized before, return STATE_CANCELLED\r\n        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\r\n            return state | STATE_CANCELLED;\r\n        } else if (isRecognized || isValid) {\r\n            if (eventType & INPUT_END) {\r\n                return state | STATE_ENDED;\r\n            } else if (!(state & STATE_BEGAN)) {\r\n                return STATE_BEGAN;\r\n            }\r\n            return state | STATE_CHANGED;\r\n        }\r\n        return STATE_FAILED;\r\n    }\r\n});\r\n\r\n/**\r\n * Pan\r\n * Recognized when the pointer is down and moved in the allowed direction.\r\n * @constructor\r\n * @extends AttrRecognizer\r\n */\r\nfunction PanRecognizer() {\r\n    AttrRecognizer.apply(this, arguments);\r\n\r\n    this.pX = null;\r\n    this.pY = null;\r\n}\r\n\r\ninherit(PanRecognizer, AttrRecognizer, {\r\n    /**\r\n     * @namespace\r\n     * @memberof PanRecognizer\r\n     */\r\n    defaults: {\r\n        event: 'pan',\r\n        threshold: 10,\r\n        pointers: 1,\r\n        direction: DIRECTION_ALL\r\n    },\r\n\r\n    getTouchAction: function() {\r\n        var direction = this.options.direction;\r\n        var actions = [];\r\n        if (direction & DIRECTION_HORIZONTAL) {\r\n            actions.push(TOUCH_ACTION_PAN_Y);\r\n        }\r\n        if (direction & DIRECTION_VERTICAL) {\r\n            actions.push(TOUCH_ACTION_PAN_X);\r\n        }\r\n        return actions;\r\n    },\r\n\r\n    directionTest: function(input) {\r\n        var options = this.options;\r\n        var hasMoved = true;\r\n        var distance = input.distance;\r\n        var direction = input.direction;\r\n        var x = input.deltaX;\r\n        var y = input.deltaY;\r\n\r\n        // lock to axis?\r\n        if (!(direction & options.direction)) {\r\n            if (options.direction & DIRECTION_HORIZONTAL) {\r\n                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;\r\n                hasMoved = x != this.pX;\r\n                distance = Math.abs(input.deltaX);\r\n            } else {\r\n                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;\r\n                hasMoved = y != this.pY;\r\n                distance = Math.abs(input.deltaY);\r\n            }\r\n        }\r\n        input.direction = direction;\r\n        return hasMoved && distance > options.threshold && direction & options.direction;\r\n    },\r\n\r\n    attrTest: function(input) {\r\n        return AttrRecognizer.prototype.attrTest.call(this, input) &&\r\n            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));\r\n    },\r\n\r\n    emit: function(input) {\r\n        this.pX = input.deltaX;\r\n        this.pY = input.deltaY;\r\n\r\n        var direction = directionStr(input.direction);\r\n        if (direction) {\r\n            this.manager.emit(this.options.event + direction, input);\r\n        }\r\n\r\n        this._super.emit.call(this, input);\r\n    }\r\n});\r\n\r\n/**\r\n * Pinch\r\n * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\r\n * @constructor\r\n * @extends AttrRecognizer\r\n */\r\nfunction PinchRecognizer() {\r\n    AttrRecognizer.apply(this, arguments);\r\n}\r\n\r\ninherit(PinchRecognizer, AttrRecognizer, {\r\n    /**\r\n     * @namespace\r\n     * @memberof PinchRecognizer\r\n     */\r\n    defaults: {\r\n        event: 'pinch',\r\n        threshold: 0,\r\n        pointers: 2\r\n    },\r\n\r\n    getTouchAction: function() {\r\n        return [TOUCH_ACTION_NONE];\r\n    },\r\n\r\n    attrTest: function(input) {\r\n        return this._super.attrTest.call(this, input) &&\r\n            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\r\n    },\r\n\r\n    emit: function(input) {\r\n        this._super.emit.call(this, input);\r\n        if (input.scale !== 1) {\r\n            var inOut = input.scale < 1 ? 'in' : 'out';\r\n            this.manager.emit(this.options.event + inOut, input);\r\n        }\r\n    }\r\n});\r\n\r\n/**\r\n * Press\r\n * Recognized when the pointer is down for x ms without any movement.\r\n * @constructor\r\n * @extends Recognizer\r\n */\r\nfunction PressRecognizer() {\r\n    Recognizer.apply(this, arguments);\r\n\r\n    this._timer = null;\r\n    this._input = null;\r\n}\r\n\r\ninherit(PressRecognizer, Recognizer, {\r\n    /**\r\n     * @namespace\r\n     * @memberof PressRecognizer\r\n     */\r\n    defaults: {\r\n        event: 'press',\r\n        pointers: 1,\r\n        time: 500, // minimal time of the pointer to be pressed\r\n        threshold: 5 // a minimal movement is ok, but keep it low\r\n    },\r\n\r\n    getTouchAction: function() {\r\n        return [TOUCH_ACTION_AUTO];\r\n    },\r\n\r\n    process: function(input) {\r\n        var options = this.options;\r\n        var validPointers = input.pointers.length === options.pointers;\r\n        var validMovement = input.distance < options.threshold;\r\n        var validTime = input.deltaTime > options.time;\r\n\r\n        this._input = input;\r\n\r\n        // we only allow little movement\r\n        // and we've reached an end event, so a tap is possible\r\n        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {\r\n            this.reset();\r\n        } else if (input.eventType & INPUT_START) {\r\n            this.reset();\r\n            this._timer = setTimeoutContext(function() {\r\n                this.state = STATE_RECOGNIZED;\r\n                this.tryEmit();\r\n            }, options.time, this);\r\n        } else if (input.eventType & INPUT_END) {\r\n            return STATE_RECOGNIZED;\r\n        }\r\n        return STATE_FAILED;\r\n    },\r\n\r\n    reset: function() {\r\n        clearTimeout(this._timer);\r\n    },\r\n\r\n    emit: function(input) {\r\n        if (this.state !== STATE_RECOGNIZED) {\r\n            return;\r\n        }\r\n\r\n        if (input && (input.eventType & INPUT_END)) {\r\n            this.manager.emit(this.options.event + 'up', input);\r\n        } else {\r\n            this._input.timeStamp = now();\r\n            this.manager.emit(this.options.event, this._input);\r\n        }\r\n    }\r\n});\r\n\r\n/**\r\n * Rotate\r\n * Recognized when two or more pointer are moving in a circular motion.\r\n * @constructor\r\n * @extends AttrRecognizer\r\n */\r\nfunction RotateRecognizer() {\r\n    AttrRecognizer.apply(this, arguments);\r\n}\r\n\r\ninherit(RotateRecognizer, AttrRecognizer, {\r\n    /**\r\n     * @namespace\r\n     * @memberof RotateRecognizer\r\n     */\r\n    defaults: {\r\n        event: 'rotate',\r\n        threshold: 0,\r\n        pointers: 2\r\n    },\r\n\r\n    getTouchAction: function() {\r\n        return [TOUCH_ACTION_NONE];\r\n    },\r\n\r\n    attrTest: function(input) {\r\n        return this._super.attrTest.call(this, input) &&\r\n            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\r\n    }\r\n});\r\n\r\n/**\r\n * Swipe\r\n * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\r\n * @constructor\r\n * @extends AttrRecognizer\r\n */\r\nfunction SwipeRecognizer() {\r\n    AttrRecognizer.apply(this, arguments);\r\n}\r\n\r\ninherit(SwipeRecognizer, AttrRecognizer, {\r\n    /**\r\n     * @namespace\r\n     * @memberof SwipeRecognizer\r\n     */\r\n    defaults: {\r\n        event: 'swipe',\r\n        threshold: 10,\r\n        velocity: 0.65,\r\n        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\r\n        pointers: 1\r\n    },\r\n\r\n    getTouchAction: function() {\r\n        return PanRecognizer.prototype.getTouchAction.call(this);\r\n    },\r\n\r\n    attrTest: function(input) {\r\n        var direction = this.options.direction;\r\n        var velocity;\r\n\r\n        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\r\n            velocity = input.velocity;\r\n        } else if (direction & DIRECTION_HORIZONTAL) {\r\n            velocity = input.velocityX;\r\n        } else if (direction & DIRECTION_VERTICAL) {\r\n            velocity = input.velocityY;\r\n        }\r\n\r\n        return this._super.attrTest.call(this, input) &&\r\n            direction & input.direction &&\r\n            input.distance > this.options.threshold &&\r\n            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\r\n    },\r\n\r\n    emit: function(input) {\r\n        var direction = directionStr(input.direction);\r\n        if (direction) {\r\n            this.manager.emit(this.options.event + direction, input);\r\n        }\r\n\r\n        this.manager.emit(this.options.event, input);\r\n    }\r\n});\r\n\r\n/**\r\n * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\r\n * between the given interval and position. The delay option can be used to recognize multi-taps without firing\r\n * a single tap.\r\n *\r\n * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\r\n * multi-taps being recognized.\r\n * @constructor\r\n * @extends Recognizer\r\n */\r\nfunction TapRecognizer() {\r\n    Recognizer.apply(this, arguments);\r\n\r\n    // previous time and center,\r\n    // used for tap counting\r\n    this.pTime = false;\r\n    this.pCenter = false;\r\n\r\n    this._timer = null;\r\n    this._input = null;\r\n    this.count = 0;\r\n}\r\n\r\ninherit(TapRecognizer, Recognizer, {\r\n    /**\r\n     * @namespace\r\n     * @memberof PinchRecognizer\r\n     */\r\n    defaults: {\r\n        event: 'tap',\r\n        pointers: 1,\r\n        taps: 1,\r\n        interval: 300, // max time between the multi-tap taps\r\n        time: 250, // max time of the pointer to be down (like finger on the screen)\r\n        threshold: 2, // a minimal movement is ok, but keep it low\r\n        posThreshold: 10 // a multi-tap can be a bit off the initial position\r\n    },\r\n\r\n    getTouchAction: function() {\r\n        return [TOUCH_ACTION_MANIPULATION];\r\n    },\r\n\r\n    process: function(input) {\r\n        var options = this.options;\r\n\r\n        var validPointers = input.pointers.length === options.pointers;\r\n        var validMovement = input.distance < options.threshold;\r\n        var validTouchTime = input.deltaTime < options.time;\r\n\r\n        this.reset();\r\n\r\n        if ((input.eventType & INPUT_START) && (this.count === 0)) {\r\n            return this.failTimeout();\r\n        }\r\n\r\n        // we only allow little movement\r\n        // and we've reached an end event, so a tap is possible\r\n        if (validMovement && validTouchTime && validPointers) {\r\n            if (input.eventType != INPUT_END) {\r\n                return this.failTimeout();\r\n            }\r\n\r\n            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;\r\n            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\r\n\r\n            this.pTime = input.timeStamp;\r\n            this.pCenter = input.center;\r\n\r\n            if (!validMultiTap || !validInterval) {\r\n                this.count = 1;\r\n            } else {\r\n                this.count += 1;\r\n            }\r\n\r\n            this._input = input;\r\n\r\n            // if tap count matches we have recognized it,\r\n            // else it has began recognizing...\r\n            var tapCount = this.count % options.taps;\r\n            if (tapCount === 0) {\r\n                // no failing requirements, immediately trigger the tap event\r\n                // or wait as long as the multitap interval to trigger\r\n                if (!this.hasRequireFailures()) {\r\n                    return STATE_RECOGNIZED;\r\n                } else {\r\n                    this._timer = setTimeoutContext(function() {\r\n                        this.state = STATE_RECOGNIZED;\r\n                        this.tryEmit();\r\n                    }, options.interval, this);\r\n                    return STATE_BEGAN;\r\n                }\r\n            }\r\n        }\r\n        return STATE_FAILED;\r\n    },\r\n\r\n    failTimeout: function() {\r\n        this._timer = setTimeoutContext(function() {\r\n            this.state = STATE_FAILED;\r\n        }, this.options.interval, this);\r\n        return STATE_FAILED;\r\n    },\r\n\r\n    reset: function() {\r\n        clearTimeout(this._timer);\r\n    },\r\n\r\n    emit: function() {\r\n        if (this.state == STATE_RECOGNIZED ) {\r\n            this._input.tapCount = this.count;\r\n            this.manager.emit(this.options.event, this._input);\r\n        }\r\n    }\r\n});\r\n\r\n/**\r\n * Simple way to create an manager with a default set of recognizers.\r\n * @param {HTMLElement} element\r\n * @param {Object} [options]\r\n * @constructor\r\n */\r\nfunction Hammer(element, options) {\r\n    options = options || {};\r\n    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);\r\n    return new Manager(element, options);\r\n}\r\n\r\n/**\r\n * @const {string}\r\n */\r\nHammer.VERSION = '2.0.4';\r\n\r\n/**\r\n * default settings\r\n * @namespace\r\n */\r\nHammer.defaults = {\r\n    /**\r\n     * set if DOM events are being triggered.\r\n     * But this is slower and unused by simple implementations, so disabled by default.\r\n     * @type {Boolean}\r\n     * @default false\r\n     */\r\n    domEvents: false,\r\n\r\n    /**\r\n     * The value for the touchAction property/fallback.\r\n     * When set to `compute` it will magically set the correct value based on the added recognizers.\r\n     * @type {String}\r\n     * @default compute\r\n     */\r\n    touchAction: TOUCH_ACTION_COMPUTE,\r\n\r\n    /**\r\n     * @type {Boolean}\r\n     * @default true\r\n     */\r\n    enable: true,\r\n\r\n    /**\r\n     * EXPERIMENTAL FEATURE -- can be removed/changed\r\n     * Change the parent input target element.\r\n     * If Null, then it is being set the to main element.\r\n     * @type {Null|EventTarget}\r\n     * @default null\r\n     */\r\n    inputTarget: null,\r\n\r\n    /**\r\n     * force an input class\r\n     * @type {Null|Function}\r\n     * @default null\r\n     */\r\n    inputClass: null,\r\n\r\n    /**\r\n     * Default recognizer setup when calling `Hammer()`\r\n     * When creating a new Manager these will be skipped.\r\n     * @type {Array}\r\n     */\r\n    preset: [\r\n        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\r\n        [RotateRecognizer, { enable: false }],\r\n        [PinchRecognizer, { enable: false }, ['rotate']],\r\n        [SwipeRecognizer,{ direction: DIRECTION_HORIZONTAL }],\r\n        [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ['swipe']],\r\n        [TapRecognizer],\r\n        [TapRecognizer, { event: 'doubletap', taps: 2 }, ['tap']],\r\n        [PressRecognizer]\r\n    ],\r\n\r\n    /**\r\n     * Some CSS properties can be used to improve the working of Hammer.\r\n     * Add them to this method and they will be set when creating a new Manager.\r\n     * @namespace\r\n     */\r\n    cssProps: {\r\n        /**\r\n         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\r\n         * @type {String}\r\n         * @default 'none'\r\n         */\r\n        userSelect: 'none',\r\n\r\n        /**\r\n         * Disable the Windows Phone grippers when pressing an element.\r\n         * @type {String}\r\n         * @default 'none'\r\n         */\r\n        touchSelect: 'none',\r\n\r\n        /**\r\n         * Disables the default callout shown when you touch and hold a touch target.\r\n         * On iOS, when you touch and hold a touch target such as a link, Safari displays\r\n         * a callout containing information about the link. This property allows you to disable that callout.\r\n         * @type {String}\r\n         * @default 'none'\r\n         */\r\n        touchCallout: 'none',\r\n\r\n        /**\r\n         * Specifies whether zooming is enabled. Used by IE10>\r\n         * @type {String}\r\n         * @default 'none'\r\n         */\r\n        contentZooming: 'none',\r\n\r\n        /**\r\n         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\r\n         * @type {String}\r\n         * @default 'none'\r\n         */\r\n        userDrag: 'none',\r\n\r\n        /**\r\n         * Overrides the highlight color shown when the user taps a link or a JavaScript\r\n         * clickable element in iOS. This property obeys the alpha value, if specified.\r\n         * @type {String}\r\n         * @default 'rgba(0,0,0,0)'\r\n         */\r\n        tapHighlightColor: 'rgba(0,0,0,0)'\r\n    }\r\n};\r\n\r\nvar STOP = 1;\r\nvar FORCED_STOP = 2;\r\n\r\n/**\r\n * Manager\r\n * @param {HTMLElement} element\r\n * @param {Object} [options]\r\n * @constructor\r\n */\r\nfunction Manager(element, options) {\r\n    options = options || {};\r\n\r\n    this.options = merge(options, Hammer.defaults);\r\n    this.options.inputTarget = this.options.inputTarget || element;\r\n\r\n    this.handlers = {};\r\n    this.session = {};\r\n    this.recognizers = [];\r\n\r\n    this.element = element;\r\n    this.input = createInputInstance(this);\r\n    this.touchAction = new TouchAction(this, this.options.touchAction);\r\n\r\n    toggleCssProps(this, true);\r\n\r\n    each(options.recognizers, function(item) {\r\n        var recognizer = this.add(new (item[0])(item[1]));\r\n        item[2] && recognizer.recognizeWith(item[2]);\r\n        item[3] && recognizer.requireFailure(item[3]);\r\n    }, this);\r\n}\r\n\r\nManager.prototype = {\r\n    /**\r\n     * set options\r\n     * @param {Object} options\r\n     * @returns {Manager}\r\n     */\r\n    set: function(options) {\r\n        extend(this.options, options);\r\n\r\n        // Options that need a little more setup\r\n        if (options.touchAction) {\r\n            this.touchAction.update();\r\n        }\r\n        if (options.inputTarget) {\r\n            // Clean up existing event listeners and reinitialize\r\n            this.input.destroy();\r\n            this.input.target = options.inputTarget;\r\n            this.input.init();\r\n        }\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * stop recognizing for this session.\r\n     * This session will be discarded, when a new [input]start event is fired.\r\n     * When forced, the recognizer cycle is stopped immediately.\r\n     * @param {Boolean} [force]\r\n     */\r\n    stop: function(force) {\r\n        this.session.stopped = force ? FORCED_STOP : STOP;\r\n    },\r\n\r\n    /**\r\n     * run the recognizers!\r\n     * called by the inputHandler function on every movement of the pointers (touches)\r\n     * it walks through all the recognizers and tries to detect the gesture that is being made\r\n     * @param {Object} inputData\r\n     */\r\n    recognize: function(inputData) {\r\n        var session = this.session;\r\n        if (session.stopped) {\r\n            return;\r\n        }\r\n\r\n        // run the touch-action polyfill\r\n        this.touchAction.preventDefaults(inputData);\r\n\r\n        var recognizer;\r\n        var recognizers = this.recognizers;\r\n\r\n        // this holds the recognizer that is being recognized.\r\n        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\r\n        // if no recognizer is detecting a thing, it is set to `null`\r\n        var curRecognizer = session.curRecognizer;\r\n\r\n        // reset when the last recognizer is recognized\r\n        // or when we're in a new session\r\n        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {\r\n            curRecognizer = session.curRecognizer = null;\r\n        }\r\n\r\n        var i = 0;\r\n        while (i < recognizers.length) {\r\n            recognizer = recognizers[i];\r\n\r\n            // find out if we are allowed try to recognize the input for this one.\r\n            // 1.   allow if the session is NOT forced stopped (see the .stop() method)\r\n            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\r\n            //      that is being recognized.\r\n            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\r\n            //      this can be setup with the `recognizeWith()` method on the recognizer.\r\n            if (session.stopped !== FORCED_STOP && ( // 1\r\n                    !curRecognizer || recognizer == curRecognizer || // 2\r\n                    recognizer.canRecognizeWith(curRecognizer))) { // 3\r\n                recognizer.recognize(inputData);\r\n            } else {\r\n                recognizer.reset();\r\n            }\r\n\r\n            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\r\n            // current active recognizer. but only if we don't already have an active recognizer\r\n            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\r\n                curRecognizer = session.curRecognizer = recognizer;\r\n            }\r\n            i++;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * get a recognizer by its event name.\r\n     * @param {Recognizer|String} recognizer\r\n     * @returns {Recognizer|Null}\r\n     */\r\n    get: function(recognizer) {\r\n        if (recognizer instanceof Recognizer) {\r\n            return recognizer;\r\n        }\r\n\r\n        var recognizers = this.recognizers;\r\n        for (var i = 0; i < recognizers.length; i++) {\r\n            if (recognizers[i].options.event == recognizer) {\r\n                return recognizers[i];\r\n            }\r\n        }\r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * add a recognizer to the manager\r\n     * existing recognizers with the same event name will be removed\r\n     * @param {Recognizer} recognizer\r\n     * @returns {Recognizer|Manager}\r\n     */\r\n    add: function(recognizer) {\r\n        if (invokeArrayArg(recognizer, 'add', this)) {\r\n            return this;\r\n        }\r\n\r\n        // remove existing\r\n        var existing = this.get(recognizer.options.event);\r\n        if (existing) {\r\n            this.remove(existing);\r\n        }\r\n\r\n        this.recognizers.push(recognizer);\r\n        recognizer.manager = this;\r\n\r\n        this.touchAction.update();\r\n        return recognizer;\r\n    },\r\n\r\n    /**\r\n     * remove a recognizer by name or instance\r\n     * @param {Recognizer|String} recognizer\r\n     * @returns {Manager}\r\n     */\r\n    remove: function(recognizer) {\r\n        if (invokeArrayArg(recognizer, 'remove', this)) {\r\n            return this;\r\n        }\r\n\r\n        var recognizers = this.recognizers;\r\n        recognizer = this.get(recognizer);\r\n        recognizers.splice(inArray(recognizers, recognizer), 1);\r\n\r\n        this.touchAction.update();\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * bind event\r\n     * @param {String} events\r\n     * @param {Function} handler\r\n     * @returns {EventEmitter} this\r\n     */\r\n    on: function(events, handler) {\r\n        var handlers = this.handlers;\r\n        each(splitStr(events), function(event) {\r\n            handlers[event] = handlers[event] || [];\r\n            handlers[event].push(handler);\r\n        });\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * unbind event, leave emit blank to remove all handlers\r\n     * @param {String} events\r\n     * @param {Function} [handler]\r\n     * @returns {EventEmitter} this\r\n     */\r\n    off: function(events, handler) {\r\n        var handlers = this.handlers;\r\n        each(splitStr(events), function(event) {\r\n            if (!handler) {\r\n                delete handlers[event];\r\n            } else {\r\n                handlers[event].splice(inArray(handlers[event], handler), 1);\r\n            }\r\n        });\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * emit event to the listeners\r\n     * @param {String} event\r\n     * @param {Object} data\r\n     */\r\n    emit: function(event, data) {\r\n        // we also want to trigger dom events\r\n        if (this.options.domEvents) {\r\n            triggerDomEvent(event, data);\r\n        }\r\n\r\n        // no handlers, so skip it all\r\n        var handlers = this.handlers[event] && this.handlers[event].slice();\r\n        if (!handlers || !handlers.length) {\r\n            return;\r\n        }\r\n\r\n        data.type = event;\r\n        data.preventDefault = function() {\r\n            data.srcEvent.preventDefault();\r\n        };\r\n\r\n        var i = 0;\r\n        while (i < handlers.length) {\r\n            handlers[i](data);\r\n            i++;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * destroy the manager and unbinds all events\r\n     * it doesn't unbind dom events, that is the user own responsibility\r\n     */\r\n    destroy: function() {\r\n        this.element && toggleCssProps(this, false);\r\n\r\n        this.handlers = {};\r\n        this.session = {};\r\n        this.input.destroy();\r\n        this.element = null;\r\n    }\r\n};\r\n\r\n/**\r\n * add/remove the css properties as defined in manager.options.cssProps\r\n * @param {Manager} manager\r\n * @param {Boolean} add\r\n */\r\nfunction toggleCssProps(manager, add) {\r\n    var element = manager.element;\r\n    each(manager.options.cssProps, function(value, name) {\r\n        element.style[prefixed(element.style, name)] = add ? value : '';\r\n    });\r\n}\r\n\r\n/**\r\n * trigger dom event\r\n * @param {String} event\r\n * @param {Object} data\r\n */\r\nfunction triggerDomEvent(event, data) {\r\n    var gestureEvent = document.createEvent('Event');\r\n    gestureEvent.initEvent(event, true, true);\r\n    gestureEvent.gesture = data;\r\n    data.target.dispatchEvent(gestureEvent);\r\n}\r\n\r\nextend(Hammer, {\r\n    INPUT_START: INPUT_START,\r\n    INPUT_MOVE: INPUT_MOVE,\r\n    INPUT_END: INPUT_END,\r\n    INPUT_CANCEL: INPUT_CANCEL,\r\n\r\n    STATE_POSSIBLE: STATE_POSSIBLE,\r\n    STATE_BEGAN: STATE_BEGAN,\r\n    STATE_CHANGED: STATE_CHANGED,\r\n    STATE_ENDED: STATE_ENDED,\r\n    STATE_RECOGNIZED: STATE_RECOGNIZED,\r\n    STATE_CANCELLED: STATE_CANCELLED,\r\n    STATE_FAILED: STATE_FAILED,\r\n\r\n    DIRECTION_NONE: DIRECTION_NONE,\r\n    DIRECTION_LEFT: DIRECTION_LEFT,\r\n    DIRECTION_RIGHT: DIRECTION_RIGHT,\r\n    DIRECTION_UP: DIRECTION_UP,\r\n    DIRECTION_DOWN: DIRECTION_DOWN,\r\n    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,\r\n    DIRECTION_VERTICAL: DIRECTION_VERTICAL,\r\n    DIRECTION_ALL: DIRECTION_ALL,\r\n\r\n    Manager: Manager,\r\n    Input: Input,\r\n    TouchAction: TouchAction,\r\n\r\n    TouchInput: TouchInput,\r\n    MouseInput: MouseInput,\r\n    PointerEventInput: PointerEventInput,\r\n    TouchMouseInput: TouchMouseInput,\r\n    SingleTouchInput: SingleTouchInput,\r\n\r\n    Recognizer: Recognizer,\r\n    AttrRecognizer: AttrRecognizer,\r\n    Tap: TapRecognizer,\r\n    Pan: PanRecognizer,\r\n    Swipe: SwipeRecognizer,\r\n    Pinch: PinchRecognizer,\r\n    Rotate: RotateRecognizer,\r\n    Press: PressRecognizer,\r\n\r\n    on: addEventListeners,\r\n    off: removeEventListeners,\r\n    each: each,\r\n    merge: merge,\r\n    extend: extend,\r\n    inherit: inherit,\r\n    bindFn: bindFn,\r\n    prefixed: prefixed\r\n});\r\n\r\nif (typeof define == TYPE_FUNCTION && define.amd) {\r\n    define(function() {\r\n        return Hammer;\r\n    });\r\n} else if (typeof module != 'undefined' && module.exports) {\r\n    module.exports = Hammer;\r\n} else {\r\n    window[exportName] = Hammer;\r\n}\r\n\r\n})(window, document, 'Hammer');\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/hammerjs/hammer.js\n **/","module.exports = function() { throw new Error(\"define cannot be used indirect\"); };\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/buildin/amd-define.js\n ** module id = 4\n ** module chunks = 0\n **/","module.exports = __webpack_amd_options__;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/buildin/amd-options.js\n ** module id = 5\n ** module chunks = 0\n **/"],"sourceRoot":""}